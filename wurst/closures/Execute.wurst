package Execute

import ErrorHandling

/**
	This package exposes a single function execute(),
	the primary use of which is to reset the OP limit.
**/

public interface ForForceCallback
	function run()

let executeForce = CreateForce()

init
	executeForce.addPlayer(localPlayer)

function executeCurrentCallback()
	lastError = null
	getCurrentCallback().run()
	setCurrentCallbackSuccess(true)

boolean array tempCallbacksSuccess
ForForceCallback array tempCallbacks
int tempCallbacksCount = 0

function pushCallback(ForForceCallback c)
	tempCallbacks[tempCallbacksCount] = c
	tempCallbacksSuccess[tempCallbacksCount] = false
	tempCallbacksCount++
	
function popCallback()
	tempCallbacksCount--
	destroy tempCallbacks[tempCallbacksCount]

function getCurrentCallbackSuccess() returns boolean
	return tempCallbacksSuccess[tempCallbacksCount - 1]

function setCurrentCallbackSuccess(boolean value)
	tempCallbacksSuccess[tempCallbacksCount - 1] = value

function getCurrentCallback() returns ForForceCallback
	return tempCallbacks[tempCallbacksCount - 1]

/**
	This function starts a new 'thread' inside the
	callback closure, which resets the dreaded OP limit to zero inside.
	This is extremely useful when you have expensive computations
	which would otherwise crash the thread.

	If the callback crashes due to an error or hitting the OP limit, it will
	error out as well.

	Note: You may use this inside a local clause, like this:
		if localPlayer == caller
			execute(...)
	But be warned that this will cause a desync, unless you are
	calling this from within another execute(...) clause.

	This will desync:
		// code called by a trigger
		if localPlayer == caller
			execute()
	This will not desync:
		execute(() -> begin
			// do some stuff here

			if localPlayer == caller
				execute(...)
		end)
**/
public function execute(ForForceCallback c)
	if not try(c)
		error("execute: thread has crashed. caused by:\n| - " + lastError)

/**
	This function works exactly the same as execute(), with
	the only difference that it will allow you to inspect
	an error if one occured.

	If the error is caused by error(), then you can inspect
	the error message using lastError from ErrorHandling.
	If the error is caused by another form of thread crash,
	such as zero division or OP limit, lastError will be null.
**/
public function try(ForForceCallback c) returns boolean
	pushCallback(c)
	executeForce.forEach(function executeCurrentCallback)
	let success = getCurrentCallbackSuccess()
	popCallback()
	return success

interface LimitedExecuteCondition 
	function check() returns boolean 
 
interface LimitedExecuteAction 
	function run() 
 
public function limitedExecuteInternal(int iterations, LimitedExecuteCondition condition, LimitedExecuteAction action) 
	execute(() -> begin 
		var i = 0 
		// iterate as many times as needed 
		while condition.check() and i < iterations 
			action.run() 
			i++

		// restart the execute if necessary 
		if condition.check() 
			limitedExecuteInternal(iterations, condition, action) 
	end) 
 
/** 
  This is an utility function which you can use to process arbitrarily large loops. 
  It functions like a while loop that will run action.run() while condition.check() == true, 
  however it will restart the execute after the specified amount of iterations. 
**/ 
public function limitedExecute(int iterations, LimitedExecuteCondition condition, LimitedExecuteAction action) 
	limitedExecuteInternal(iterations, condition, action) 
	destroy condition 
	destroy action