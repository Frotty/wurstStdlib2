package Execute

import ErrorHandling

/**
	This package exposes a single function execute(),
	the primary use of which is to reset the OP limit.
**/

public interface ForForceCallback
	function run()

let executeForce = CreateForce()

init
	executeForce.addPlayer(localPlayer)

function executeCurrentCallback()
	getCurrentCallback().run()
	setCurrentCallbackSuccess(true)

boolean array tempCallbacksSuccess
ForForceCallback array tempCallbacks
int tempCallbacksCount = 0

function pushCallback(ForForceCallback c)
	tempCallbacks[tempCallbacksCount] = c
	tempCallbacksSuccess[tempCallbacksCount] = false
	tempCallbacksCount++
	
function popCallback()
	tempCallbacksCount--
	destroy tempCallbacks[tempCallbacksCount]

function getCurrentCallbackSuccess() returns boolean
	return tempCallbacksSuccess[tempCallbacksCount - 1]

function setCurrentCallbackSuccess(boolean value)
	tempCallbacksSuccess[tempCallbacksCount - 1] = true

function getCurrentCallback() returns ForForceCallback
	return tempCallbacks[tempCallbacksCount - 1]

/**
	This function starts a new 'thread' inside the
	callback closure, which resets the dreaded OP limit to zero inside.
	This is extremely useful when you have expensive computations
	which would otherwise crash the thread.

	This function also checks that the callback it executes finishes correctly
	and without errors or hitting the OP limit. If it does, it will error out as well.

	Note: You may use this inside a local clause, like this:
		if localPlayer == caller
			execute(...)
	But be warned that this will cause a desync, unless you are
	calling this from within another execute(...) clause.

	This will desync:
		// code called by a trigger
		if localPlayer == caller
			execute()
	This will not desync:
		execute(() -> begin
			// do some stuff here

			if localPlayer == caller
				execute(...)
		end)
**/
public function execute(ForForceCallback c)
	pushCallback(c)
	executeForce.forEach(function executeCurrentCallback)
	let success = getCurrentCallbackSuccess()
	if not success
		error("execute: callback has failed")
	popCallback()

interface LimitedExecuteCondition
	function check() returns boolean

interface LimitedExecuteAction
	function run()

public function limitedExecuteInternal(int iterations, LimitedExecuteCondition condition, LimitedExecuteAction action)
	execute(() -> begin
		var i = 0
		// iterate as many times as needed
		while condition.check() and i < iterations
			action.run()
			i++

		// restart the execute if necessary
		if condition.check()
			limitedExecuteInternal(iterations, condition, action)
	end)

/**
	This is an utility function which you can use to process arbitrarily large loops.
	It functions like a while loop that will run action.run() while condition.check() == true,
	however it will restart the execute after the specified amount of iterations.
**/
public function limitedExecute(int iterations, LimitedExecuteCondition condition, LimitedExecuteAction action)
	limitedExecuteInternal(iterations, condition, action)
	destroy condition
	destroy action