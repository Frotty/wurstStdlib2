package Persistable

import PacketIO
import Encryptor
import Network
import DataInterfaces
import Base64Data
import Box

public enum LoadStatus
    SUCCESS
    FAIL_LOAD
    FAIL_TRANSFER
    FAIL_DESERIALIZE
    FAIL_NO_PLAYER

public interface PersistableLoadCallback
    function onLoaded(LoadStatus status)

public interface PersistableSaveCallback
    function onSaved()

public abstract class Persistable implements DataSerializable
    protected player owner
    private Encryptor encryptor

    construct(player owner)
        this.owner = owner
    
    construct(player owner, Encryptor encryptor)
        this.owner = owner
        this.encryptor = encryptor

    ondestroy
        if encryptor != null
            destroy encryptor

    abstract function getPath() returns string
    protected function onLoaded(LoadStatus _status)
    protected function onSaved()

    protected function getWriter() returns DataWriter
        return new Base64DataWriter(MAX_PACKET_LENGTH)

    protected function getReader(BigString data) returns DataReader
        return new Base64DataDecoder().decode(data)

    private function readIntoNetwork(Network network) returns boolean
        Box<DataReader> readerBox = new Box<DataReader>(null)

        let readSuccess = try() ->
            PacketReader.open(getPath())
            let data = PacketReader.readBigString()
            readerBox.inner = getReader(data)

        let reader = readerBox.inner
        destroy readerBox

        if readSuccess and reader != null
            network.write() (writer) ->
                writer.writeInt(LoadStatus.SUCCESS castTo int)

            let deserializeSuccess = try() ->
                reader.readSerializable(this)

            if deserializeSuccess
                let transferSuccess = try() ->
                    network.write() (writer) ->
                        writer.writeSerializable(this)
                
                if transferSuccess
                    destroy reader
                    return true
                else
                    network.write() (writer) ->
                        writer.clear()
                        writer.writeInt(LoadStatus.FAIL_TRANSFER castTo int)
            else
                network.write() (writer) ->
                    writer.clear()
                    writer.writeInt(LoadStatus.FAIL_DESERIALIZE castTo int)
        else
            network.write() (writer) ->
                writer.clear()
                writer.writeInt(LoadStatus.FAIL_LOAD castTo int)

        destroy reader
        return false

    private function finishLoad(LoadStatus status, PersistableLoadCallback callback)
        onLoaded(status)
        if callback != null
            callback.onLoaded(status)
            destroy callback

    private function finishSave(PersistableSaveCallback callback)
        onSaved()
        if callback != null
            callback.onSaved()
            destroy callback

    function load(PersistableLoadCallback callback)
        let network = new Network(owner)

        if localPlayer == owner
            readIntoNetwork(network)

        network.start() (status, reader) ->
            if status == NetworkResult.ABORTED
                finishLoad(LoadStatus.FAIL_NO_PLAYER, callback)
            else
                let loadStatus = reader.readInt() castTo LoadStatus

                if loadStatus == LoadStatus.SUCCESS
                    if localPlayer != owner
                    this.deserialize(reader)
                    finishLoad(LoadStatus.SUCCESS, callback)
                else
                    finishLoad(loadStatus, callback)

    function load()
        load(null)

    function save(PersistableSaveCallback callback)
        if localPlayer == owner
            let writer = getWriter()
            writer.writeSerializable(this)
            let data = writer.intoEncoder().encode()
            PacketWriter.initialize()
            PacketWriter.write(data)
            PacketWriter.commit(getPath())
        finishSave(callback)
    
    function save()
        save(null)