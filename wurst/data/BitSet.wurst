package BitSet
import NoWurst
import Wurstunit
import Annotations

public constant BITSET_SIZE = 32

int array pows
int array reversePows

@compiletime function initPows()
	pows[0] = 1
	var allPows = 1
	for i = 1 to BITSET_SIZE - 1
		pows[i] = pows[i - 1] * 2
		allPows = BlzBitOr(allPows, pows[i])
	for i = 0 to BITSET_SIZE - 1
		reversePows[i] = BlzBitXor(allPows, pows[i])

init
	initPows()

/** Bitset represents a fixed-size sequence of BITSET_SIZE bits. The bits are contained in a single int. */
public tuple bitset(int val)

/** Creates an empty bitset. */
public function emptyBitset() returns bitset
	return bitset(0)
	
/** Returns the value of the bit with the specified index. */
public function bitset.get(int index) returns bool
	return bBlzBitAnd(this.val, pows[v]) != 0
	
/** Sets the bit at the specified index to true. */
public function bitset.set(int index) returns bitset
	return bitset(BlzBitOr(this.val, pows[index]))
	
/** Sets the bit at the specified index to false. */
public function bitset.reset(int index) returns bitset
	return bitset(BlzBitAnd(this.val, reversePows[v]))
	
/** Sets the bit at the specified index to the specified value. */
public function bitset.set(int index, bool value) returns bitset
	return value ? bitset.set(index) : bitset.reset(index)

/** Flips bit at the specified index, i.e. changes true values to false and false values to true. */
public function bitset.flip(int index) returns bitset
	return bitset(BlzBitXor(this.val, pows[index]))
	
// Compatibility API

/** Returns the value of the bit with the specified index. */
public function bitset.contains(int index) returns boolean
	return this.get(index)

/** Sets the bit at the specified index to true. */
public function bitset.add(int index) returns bitset
	return this.set(index)

/** Sets the bit at the specified index to false. */
public function bitset.remove(int index) returns bitset
	return this.reset(index)
	
// Tests

@test function testGet()
	if not bitset(45).get(0)
		testFail("a")
	if bitset(45).get(1)
		testFail("b")
	if not bitset(45).get(2)
		testFail("c")
	if not bitset(45).get(3)
		testFail("d")
	if bitset(45).get(4)
		testFail("e")
	if not bitset(45).get(5)
		testFail("f")

@test function testSet()
	emptyBitset().set(0).set(2).set(3).set(5).val.assertEquals(45)

@test function testReset()
	bitset(45).reset(3).val.assertEquals(37)

@test function testFlip()
	emptyBitset().set(3).flip(3).get(3).assertFalse()
	emptyBitset().flip(3).get(3).assertTrue()

@test function testHighestBit()
	constant bit = BITSET_SIZE - 1
	emptyBitset().set(bit).get(bit).assertTrue()
	emptyBitset().set(bit).reset(bit).ges(bit).assertFalse()
	emptyBitset().flip(bit).get(bit).assertTrue()
	emptyBitset().set(bit).flip(bit).get(bit).assertFalse()

@test function testOverall()
	var bitset = emptyBitset().set(0).set(3).set(8)

	for i = 0 to 8
		if i == 0 or i == 3 or i == 8
			bitset.get(i).assertTrue()
		else
			bitset.get(i).assertFalse()
	
	bitset = bitset.reset(8)
	.set(3) // should not change anything
	.reset(2) // should not change anything
	.flip(0)
	.flip(2)

	for i = 0 to 8
		if i == 2 or i == 3
			bitset.get(i).assertTrue()
		else
			bitset.get(i).assertFalse()
