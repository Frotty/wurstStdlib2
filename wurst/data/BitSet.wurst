package BitSet
import NoWurst
import Wurstunit
import Annotations

int array pows
int array reversePows
constant maxPow = 31

@compiletime function initPows()
	pows[0] = 1
	var allPows = 1
	for i = 1 to maxPow
		pows[i] = pows[i - 1] * 2
		allPows = BlzBitOr(allPows, pows[i])
	for i = 0 to maxPow
		reversePows[i] = BlzBitXor(allPows, pows[i])

init
	initPows()

public tuple bitset(int val)

function bitset.containsPow(int pow) returns boolean
	return BlzBitAnd(this.val, pow) != 0

public function emptyBitset() returns bitset
	return bitset(0)

public function bitset.contains(int v) returns boolean
	return BlzBitAnd(this.val, pows[v]) != 0

public function bitset.add(int v) returns bitset
	return bitset(BlzBitOr(this.val, pows[v]))

public function bitset.remove(int v) returns bitset
	return bitset(BlzBitAnd(this.val, reversePows[v]))

public function bitset.flip(int v) returns bitset
	return bitset(BlzBitXor(this.val, pows[v]))

// Tests:
@test function testContains()
	if not bitset(45).contains(0)
		testFail("a")
	if bitset(45).contains(1)
		testFail("b")
	if not bitset(45).contains(2)
		testFail("c")
	if not bitset(45).contains(3)
		testFail("d")
	if bitset(45).contains(4)
		testFail("e")
	if not bitset(45).contains(5)
		testFail("f")

@test function testAdd()
	emptyBitset().add(0).add(2).add(3).add(5).val.assertEquals(45)

@test function testRemove()
	bitset(45).remove(3).val.assertEquals(37)

@test function testFlip()
	emptyBitset().add(3).flip(3).contains(3).assertFalse()
	emptyBitset().flip(3).contains(3).assertTrue()

@test function testOverall()
	var bitset = emptyBitset().add(0).add(3).add(8)

	for i = 0 to 8
		if i == 0 or i == 3 or i == 8
			bitset.contains(i).assertTrue()
		else
			bitset.contains(i).assertFalse()
	
	bitset = bitset.remove(8)
	.add(3) // should do nothing
	.remove(2) // should do nothing
	.flip(0)
	.flip(2)

	for i = 0 to 8
		if i == 2 or i == 3
			bitset.contains(i).assertTrue()
		else
			bitset.contains(i).assertFalse()
