package StringBuffer

import Table
import ErrorHandling
import LinkedList
import Buffer
import Execute

abstract class Executor
	use ExecuteModule

enum ValueType
	INTEGER
	REAL
	STRING
	BOOLEAN
	INVALID

function ValueType.toString() returns string
	var id = ""
	switch this
		case INTEGER
			id = "i"
		case REAL
			id = "r"
		case BOOLEAN
			id = "b"
		case STRING
			id = "s"
		case INVALID
			error("ValueType: INVALID should never be serializable")
	return id

function valueTypeFromString(string value) returns ValueType
	var valueType = ValueType.INVALID
	switch value
		case "i"
			valueType = ValueType.INTEGER
		case "r"
			valueType = ValueType.REAL
		case "b"
			valueType = ValueType.BOOLEAN
		case "s"
			valueType = ValueType.STRING
	return valueType

class ChunkElement
	var content = ""

	construct(string value)
		content = value

/**
	Abstract class providing the scaffolding required to build
	your own string-based serializer/deserializer.

	This class is meant to produce/consume "chunks" of data of the specified
	length, to be fed into IO primitives which expect strings under a certain length.

	WRITING:
	To push raw string data into the buffer, use pushString().
	After finishing writing, call .flush() or .flushBuffer(), this will
	push any remaining unchunked data into the buffer.

	READING:
	Use popAll() to pop all data in the current chunk, and load the next chunk.
	Use popStringUntil() to return a string up until the specified character.
	Use popString() to return a string of a specific length.

	MISC:
	Use pushChunk() to push a serialized chunk of data as-is into the buffer, to be deserialized
	later on.
	Use popChunk() to pop a serialized chunk of data as-is from the buffer, to be written into a file
	or elsewhere.
	Use hasChunk() to check if there are any chunks left.
**/
public abstract class AbstractStringBuffer extends AbstractBuffer
	protected static constant MAX_BACKBUFFER_SIZE = 1024
	protected static constant MAX_BUFFER_SIZE = 2048

	// list of "chunks" that can grow/shrink as required
	protected var chunks = new LinkedList<ChunkElement>()
	protected var readBuffer = ""
	protected var writeBuffer = ""

	// this is the maximum size of each chunk element
	// we should keep this below MAX_BACKBUFFER_SIZE so that currentBuffer can reliably
	// fit at least two buffers of that size, while staying under MAX_BUFFER_SIZE characters
	private int maxBufferSize

	construct(int maxSize)
		if maxSize > MAX_BACKBUFFER_SIZE
			Log.warn("Trying to instantiate an instance of AbstractStringBuffer with maxSize=" + maxSize.toString() +
			", but MAX_BACKBUFFER_SIZE is " + MAX_BACKBUFFER_SIZE.toString())
			Log.warn("The value will be clamped to " + MAX_BACKBUFFER_SIZE.toString())

		maxBufferSize = min(maxSize, MAX_BACKBUFFER_SIZE)

	construct()
		maxBufferSize = MAX_BACKBUFFER_SIZE

	ondestroy
		for chunk in chunks
			destroy chunk
		destroy chunks

	/*
		Write auxiliary methods.
	*/

	/**
		Call this function once after you've finished writing to commit any pending data.
	**/
	function flush()
		if writeBuffer.length() > 0
			flushBuffer()

	// flushes the current buffer to the chunks
	protected function flushBuffer()
		chunks.push(new ChunkElement(writeBuffer))
		writeBuffer = ""

	// pushes a string to the current buffer, flushing if we exceed maxBufferSize
	protected function pushString(string data)
		var remaining = data
		if data.length() > MAX_BUFFER_SIZE
			error("AbstractStringBuffer: trying to push a string above MAX_BUFFER_SIZE")

		var overflow = data.length() + writeBuffer.length() - maxBufferSize
		while overflow > 0
			// we do not want the buffer to exceed maxBufferSize for each flush
			let toAppend = min(remaining.length(), maxBufferSize - writeBuffer.length())
			writeBuffer += remaining.substring(0, toAppend)
			remaining = remaining.substring(toAppend)
			overflow -= maxBufferSize
			flushBuffer()

		writeBuffer += remaining

	/*
		Read auxiliary methods.
	*/

	private function isDataAvailable() returns boolean
		return chunks.size() > 0 or readBuffer.length() > 0

	function canRead() returns boolean
		return isDataAvailable()

	private function checkDataAvailable()
		if not isDataAvailable()
			fail(BufferFailureMode.EOF, "reached EOF")

	// loads the next chunk into the buffer
	private function nextChunk()
		if chunks.isEmpty()
			fail(BufferFailureMode.EOF, "reached EOF")
			return

		let chunk = chunks.dequeue()
		readBuffer += chunk.content
		destroy chunk

	// returns all data remaining in the buffer and loads the next chunk
	protected function popAll() returns string
		checkDataAvailable()
		let value = readBuffer
		readBuffer = ""
		nextChunk()
		return value

	// attempts to load a string up to the next specified character
	protected function popStringUntil(string terminator) returns string
		var value = ""
		var terminatorIndex = -1
		while terminatorIndex < 0
			// if we start exceeding the buffer limit in the return value, that
			// probably means something is wrong and that the input data is malformed
			if value.length() > MAX_BUFFER_SIZE
				fail(BufferFailureMode.MALFORMED_INPUT, "failed to find terminator character")
				return null

			terminatorIndex = readBuffer.indexOf(terminator)

			if terminatorIndex < 0
				// if we haven't found the terminator character in the buffer,
				// we can be sure that we'll need to return the contents of the
				// current buffer, and then search in the next chunk
				value += popAll()
			else
				// add the contents up to the terminator character, and then pop
				// it from the buffer
				value += readBuffer.substring(0, terminatorIndex)
				// skip the terminator
				readBuffer = readBuffer.substring(terminatorIndex + 1)
		return value

	// returns length amount of characters from the buffer, if there is enough
	protected function popString(int length) returns string
		if BUFFER_SAFETY_CHECKS_ENABLED and length > MAX_BUFFER_SIZE
			fail(BufferFailureMode.INTERNAL_ERROR, "trying to pop a string above max size")

		// length 0 is a special case for a string, so just return it immediately
		if length == 0
			return ""

		checkDataAvailable()
		// if there isn't enough data in the readBuffer, load additional chunks
		while isValid() and readBuffer.length() < length
			nextChunk()

		if isValid()
			// if we haven't errored out at this point, it's safe to pop the string
			let value = readBuffer.substring(0, length)
			readBuffer = readBuffer.substring(length)

			return value
		else
			return null

	/*
		Chunk manipulation.
	*/

	function pushChunk(string value)
		chunks.push(new ChunkElement(value))

	function hasChunk() returns boolean
		return chunks.size() > 0

	function popChunk() returns string
		if not hasChunk()
			error("OrderedStringBuffer: trying to pop non-existent chunk")
		let chunk = chunks.dequeue()
		let value = chunk.content
		destroy chunk
		return value
	
	override function clear()
		for chunk in chunks
			destroy chunk
		chunks.clear()
		readBuffer = ""
		writeBuffer = ""

	/*
		Adapters.
	*/
	abstract function moveTo(Buffer buffer)
		

/**
	Implementation of Buffer backed by a list of strings. Everything
	is serialized/deserialized into strings.

	Since we may be dealing with user input in this class, it is
	important to keep in mind that it might be malformed or invalid.

	For this reason, the class doesn't instantly error out on attempts
	to read incorrect data, and the users of the class should call
	OrderedStringBuffer.isValid() during/after reading data to make sure that
	it is correct.

	Trying to read from a buffer that has entered an erroneous state
	will not terminate the thread, but will instead return default values:
		ints - 0
		booleans - false
		reals - 0.0
		strings - null

	This allows you to check for the error right after reading.

	You can use OrderedStringBuffer.getFailure() and OrderedStringBuffer.getErrorMessage()
	to inspect the error further, if there is any.

	The serialized values keep track of their type, and do not fixed-length
	encoding anywhere, instead relying on a special 'terminator' character
	to determine the end of a value.

	Strings are encoded with a length-field prepending them.

	Examples of serialized values:
		1. "i50392|" - int 50392
		2. "r3.1415|" - real 3.1415
		3. "b1" - boolean true
		4. "s10|0123456789" - string 0123456789
		5. "s5|01234i10|b1b0r1.0005|" - string 012345, int 10, bool true, bool false, real 1.0005
**/
public class OrderedStringBuffer extends AbstractStringBuffer
	private static constant TERMINATOR = "|"

	construct()
		super()

	construct(int maxBufferSize)
		super(maxBufferSize)

	private function pushTerminator()
		pushString(TERMINATOR)

	private function pushTypeIdentifier(ValueType valueType)
		pushString(valueType.toString())

	// attempts to read the current position as a value type
	private function popTypeIdentifier() returns ValueType
		let valueType = valueTypeFromString(popString(1))
		if valueType == ValueType.INVALID
			fail(BufferFailureMode.MALFORMED_INPUT, "malformed input")
		return valueType

	// checks that we are reading the correct type
	private function checkType(ValueType toCheck) returns boolean
		let currentType = popTypeIdentifier()
		// might have malformed input after popping type identifier, so check that first
		if not isValid()
			return false
		if currentType != toCheck
			fail(BufferFailureMode.INCORRECT_TYPE, "tried to read " + toCheck.toString() + " but was " + currentType.toString())
			return false
		return true

	/*
		Interface implementation
	*/

	override function writeInt(int value)
		checkWrite()
		pushTypeIdentifier(ValueType.INTEGER)
		pushString(value.toString())
		pushTerminator()

	override function writeReal(real value)
		checkWrite()
		pushTypeIdentifier(ValueType.REAL)
		pushString(value.toString())
		pushTerminator()

	override function writeString(string value)
		if value.length() > MAX_BUFFER_SIZE
			error("OrderedStringBuffer: trying to write string above MAX_BUFFER_SIZE")
		checkWrite()
		pushTypeIdentifier(ValueType.STRING)
		pushString(value.length().toString())
		pushTerminator()
		pushString(value)

	override function writeBoolean(bool value)
		checkWrite()
		pushTypeIdentifier(ValueType.BOOLEAN)
		pushString(value.toInt().toString())

	private function readIntInternal() returns int
		return popStringUntil(TERMINATOR).toInt()

	override function readInt() returns int
		checkRead()
		return checkType(ValueType.INTEGER) ? readIntInternal() : 0

	override function readReal() returns real
		checkRead()
		return checkType(ValueType.REAL) ? popStringUntil(TERMINATOR).toReal() : 0

	override function readString() returns string
		checkRead()
		string value = null
		if checkType(ValueType.STRING)
			let length = readIntInternal()
			if length < 0 or length > MAX_BUFFER_SIZE
				fail(BufferFailureMode.MALFORMED_INPUT, "tried to read string of length " + length.toString() +
					", but max is " + MAX_BUFFER_SIZE.toString())
			else
				value = popString(length)
		return value

	override function readBoolean() returns bool
		checkRead()
		return checkType(ValueType.BOOLEAN) ? (popString(1) == "1") : false

	function peekType() returns ValueType
		let valueType = popTypeIdentifier()
		// put the identifier back into the buffer
		readBuffer = valueType.toString() + readBuffer
		return valueType

	private function transferValueTo(Buffer sink)
		let valueType = this.peekType()
	
		switch valueType
			case INTEGER
				sink.writeInt(this.readInt())
			case REAL
				sink.writeReal(this.readReal())
			case STRING
				sink.writeString(this.readString())
			case BOOLEAN
				sink.writeBoolean(this.readBoolean())
			default

	override function moveTo(Buffer buffer)
		Executor.executeWhile(64, () -> this.canRead()) ->
			this.transferValueTo(buffer)