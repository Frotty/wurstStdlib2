package Quaternions
import NoWurst
import String
import Matrices


/* Great thanks to euclideanspace.com for wide explanations. */


public tuple quat(real x, real y, real z, real w)

public constant IDENTITYQ = quat(0, 0, 0, 1)
public constant ZEROQ = quat(0, 0, 0, 0)

public function quat.op_plus(quat q) returns quat
    return quat(this.x + q.x, this.y + q.y, this.z + q.z, this.w + q.w)

public function quat.op_plus(real scalar) returns quat
    return quat(this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar)

public function real.op_plus(quat q) returns quat
    return q + this

public function quat.op_minus(quat q) returns quat
    return quat(this.x - q.x, this.y - q.y, this.z - q.z, this.w - q.w)

public function quat.op_minus(real scalar) returns quat
    return quat(this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar)

public function quat.op_mult(real scalar) returns quat
    return quat(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar)

public function real.op_mult(quat q) returns quat
    return q * this

public function quat.dot(quat q) returns real
    return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w

/** Represents the composition of two rotations. */
public function quat.cross(quat q) returns quat
    return quat(this.x * q.w + this.y * q.z - this.z * q.y + this.w * q.x,
                -this.x * q.z + this.y * q.w + this.z * q.x + this.w * q.y,
                this.x * q.y - this.y * q.x + this.z * q.w + this.w * q.z,
                -this.x * q.x - this.y * q.y - this.z * q.z + this.w * q.w)

/** Represents the same rotation in opposite direction. */
public function quat.conj() returns quat
    return quat(-this.x, -this.y, -this.z, this.w)

public function quat.length() returns real
    return SquareRoot(this.x.squared() + this.y.squared() + this.z.squared() + this.w.squared())

/** Returns zero quaternion if lenght is zero. */
public function quat.norm() returns quat
    let length = this.length()
    return length > 0.002 ? quat(this.x / length, this.y / length, this.z / length, this.w / length) : ZEROQ

public function quat.toMatrix() returns mat3
    var q = this.norm()
    var x = q.x
    var y = q.y
    var z = q.z
    var w = q.w
    return mat3(1 - 2 * y * y - 2 * z * z,      2 * x * y - 2 * z * w,      2 * x * z + 2 * y * w,
                2 * x * y + 2 * z * w,          1 - 2 * x * x - 2 * z * z,  2 * y * z - 2 * x * w,
                2 * x * z - 2 * y * w,          2 * y * z + 2 * x * w,      1 - 2 * x * x - 2 * y * y)

/** Linear intERPolation.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.lerp(quat q, real p) returns quat
    quat result
    if this.dot(q).abs() < 0.002
        result = q
    else
        result = this * (1 - p) + q * p
    return result

/** Linear intERPolation.
Always chooses the SHORTEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.lerpShort(quat q, real p) returns quat
    return this.dot(q) > 0 ? this.lerp(q, p) : this.lerp(quat(-q.x, -q.y, -q.z, -q.w), p)

/** Linear intERPolation.
Always chooses the LONGEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.lerpLong(quat q, real p) returns quat
    return this.dot(q) < 0 ? this.lerp(q, p) : this.lerp(quat(-q.x, -q.y, -q.z, -q.w), p)

/** Normalized Linear intERPolation.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.nlerp(quat q, real p) returns quat
    return this.lerp(q, p).norm()

/** Normalized Linear intERPolation.
Always chooses the SHORTEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.nlerpShort(quat q, real p) returns quat
    return this.dot(q) > 0 ? this.nlerp(q, p) : this.nlerp(quat(-q.x, -q.y, -q.z, -q.w), p)

/** Normalized Linear intERPolation.
Always chooses the LONGEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
public function quat.nlerpLong(quat q, real p) returns quat
    return this.dot(q) < 0 ? this.nlerp(q, p) : this.nlerp(quat(-q.x, -q.y, -q.z, -q.w), p)

/**Spherical Linear intERPolation. Interpolates between two rotations.
q - targeted quaternion. p - progress from 0 to 1. */
@deprecated("Slerp is the least efficient approach in performance so try to avoid using it, unless you need constant angular velocity. Nlerp is better solution in most cases.")
public function quat.slerp(quat q, real p) returns quat
    quat result
    var dot = this.dot(q)
    if dot.abs() < 0.002
        result = q
    else
        var theta = dot.acos()
        result = ((1 - p) * theta).sin() / theta.sin() * this + (p * theta).sin() / theta.sin() * q
    return result

/**Spherical Linear intERPolation. Interpolates between two rotations.
Always chooses the SHORTEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
@deprecated("Slerp is the least efficient approach in performance so try to avoid using it, unless you need constant angular velocity. Nlerp is better solution in most cases.")
public function quat.slerpShort(quat q, real p) returns quat
    return this.dot(q) > 0 ? this.slerp(q, p) : this.slerp(quat(-q.x, -q.y, -q.z, -q.w), p)

/**Spherical Linear intERPolation. Interpolates between two rotations.
Always chooses the LONGEST way between rotations.
q - targeted quaternion. p - progress from 0 to 1. */
@deprecated("Slerp is the least efficient approach in performance so try to avoid using it, unless you need constant angular velocity. Nlerp is better solution in most cases.")
public function quat.slerpLong(quat q, real p) returns quat
    return this.dot(q) < 0 ? this.slerp(q, p) : this.slerp(quat(-q.x, -q.y, -q.z, -q.w), p)
    
public function quat.toString() returns string
    return "Quaternion [X {0}, Y {1}, Z {2}, W {3}]".format(this.x.toString(), this.y.toString(), this.z.toString(), this.w.toString())

/** Extracts Euler-angles (Tait-Bryan) from a quaternion. Order of the result is X-Y-Z.
There's no universal way for quaternions thus we have to use quat-matrix conversion first. */
public function quat.toEuler() returns vec3
    return this.norm().toMatrix().toEuler()

/** Creates a quaternion from rotation axis and angle. */
public function vec3.toQuat(angle angl) returns quat
    let v = this.norm()
    let sin = (angl / 2).sin()
    return quat(v.x * sin, v.y * sin, v.z * sin,  (angl / 2).cos())

/** Rotates a vector by a quaternion. */
public function vec3.rotate(quat q) returns vec3
    let tmp = quat(this.x, this.y, this.z, 0)
    let result = q.cross(tmp).cross(q.conj())
    return vec3(result.x, result.y, result.z)

