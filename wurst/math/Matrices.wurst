package Matrices
import NoWurst
import Vectors
import _Primitives
import Printing


/* Great thanks to euclideanspace.com for wide explanations. */


/** Matrix 2x2
00 01
10 11
*/
public tuple mat2(real m00, real m01, real m10, real m11)

public constant ZERO22 = mat2(0, 0, 0, 0)

public constant IDENTITY22 = mat2(
    1, 0,
    0, 1)

tuple inverseresult22(bool success, mat2 matrix)

/** Matrix 3x3
00 01 02
10 11 12
20 21 22
*/
public tuple mat3(  real m00, real m01, real m02,
                    real m10, real m11, real m12,
                    real m20, real m21, real m22)

public constant ZERO33 = mat3(0, 0, 0, 0, 0, 0, 0, 0, 0)

public constant IDENTITY33 = mat3(
    1, 0, 0,
    0, 1, 0,
    0, 0, 1)

tuple inverseresult33(bool success, mat3 matrix)

/* =========== 2X2 MATRIX =========== */
             
public function mat2.op_plus(mat2 m) returns mat2
    return mat2(this.m00 + m.m00,   this.m01 + m.m01,
                this.m10 + m.m10,   this.m11 + m.m11)

public function mat2.op_minus(mat2 m) returns mat2
    return mat2(this.m00 - m.m00,   this.m01 - m.m01,
                this.m10 - m.m10,   this.m11 - m.m11)

public function mat2.op_minus(real scalar) returns mat2
    return mat2(this.m00 - scalar,  this.m01 - scalar,
                this.m10 - scalar,  this.m11 - scalar)

public function mat2.op_plus(real scalar) returns mat2
    return mat2(this.m00 + scalar,  this.m01 + scalar,
                this.m10 + scalar,  this.m11 + scalar)
    
public function mat2.op_mult(real scalar) returns mat2
    return mat2(this.m00*scalar,    this.m01*scalar,
                this.m10*scalar,    this.m11*scalar)

public function real.op_mult(mat2 m) returns mat2
    return m*this

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function mat2.op_mult(vec2 v) returns vec2
    return vec2(this.m00*v.x + this.m01*v.y, this.m10*v.x + this.m11*v.y)

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function vec2.op_mult(mat2 m) returns vec2
    return vec2(this.x*m.m00 + this.y*m.m10, this.x*m.m01 + this.y*m.m11)

public function mat2.op_mult(mat2 m) returns mat2
    return mat2(this.m00*m.m00 + this.m01*m.m10,    this.m00*m.m01 + this.m01*m.m11, 
                this.m10*m.m00 + this.m11*m.m10,    this.m10*m.m01 + this.m11*m.m11)

/** Returns matrix' column by id as a vector or zero-vector if doesn't exist. */
public function mat2.col(int id) returns vec2
    vec2 result
    switch id
        case 0
            result = vec2(this.m00, this.m10)
        case 1
            result = vec2(this.m01, this.m11)
        default
            result = ZERO2
    return result

/** Returns matrix' row by id as a vector or zero-vector if doesn't exist. */
public function mat2.row(int id) returns vec2
    vec2 result
    switch id
        case 0
            result = vec2(this.m00, this.m01)
        case 1
            result = vec2(this.m10, this.m11)
        default
            result = ZERO2
    return result

public function mat2.determinant() returns real
    return this.m00*this.m11 - this.m01*this.m10

/** Flips the matrix over its main diagonale.
Result of transposing for rotation matrix is its inverse matrix. */
public function mat2.transpose() returns mat2
    return mat2(this.m00, this.m10,
                this.m01, this.m11)

/** Finds inverse matrix.
Returns tuple inverseresult22(bool success, mat2 matrix) where 'success' is true if the inverse matrix exists and 'matrix' is the inverse matrix.
If there's no inverse matrix 'success' is false and 'matrix' is zero matrix. */
public function mat2.inverse() returns inverseresult22
    let d = this.determinant()
    var inverse = inverseresult22(d.abs() > 0.002, ZERO22)
    if d.abs().isBetween(0.998, 1.002)
        inverse.matrix = this.transpose()
    else if d.abs() > 0.002
        let tmp = mat2( this.m11, -this.m01,
                        -this.m10, this.m00)
        inverse.matrix = 1/d*tmp
    return inverse

public function mat2.toString() returns string
    return "Matrix 2x2\n{0} {1}\n{2} {3}".format(
        this.m00.toString(), this.m01.toString(),
        this.m10.toString(), this.m11.toString())

/** Creates rotation matrix from angle. */
public function angle.toMatrix() returns mat2
    return mat2(this.cos(), -this.sin(),
                this.sin(), this.cos())

/** Creates scaling 2x2 matrix from a vector. */
public function vec2.toScaling() returns mat2
    return mat2(this.x, 0,
                0,      this.y)
    
/* =========== 3X3 MATRIX =========== */

public function mat3.op_plus(mat3 m) returns mat3
    return mat3(this.m00 + m.m00,    this.m01 + m.m01,    this.m02 + m.m02,
                this.m10 + m.m10,    this.m11 + m.m11,    this.m12 + m.m12,
                this.m20 + m.m20,    this.m21 + m.m21,    this.m22 + m.m22)

public function mat3.op_plus(real scalar) returns mat3
    return mat3(this.m00 + scalar,    this.m01 + scalar,    this.m02 + scalar,
                this.m10 + scalar,    this.m11 + scalar,    this.m12 + scalar,
                this.m20 + scalar,    this.m21 + scalar,    this.m22 + scalar)

public function mat3.op_minus(mat3 m) returns mat3
    return mat3(this.m00 - m.m00,    this.m01 - m.m01,    this.m02 - m.m02,
                this.m10 - m.m10,    this.m11 - m.m11,    this.m12 - m.m12,
                this.m20 - m.m20,    this.m21 - m.m21,    this.m22 - m.m22)
        
public function mat3.op_minus(real scalar) returns mat3
    return mat3(this.m00 - scalar,    this.m01 - scalar,    this.m02 - scalar,
                this.m10 - scalar,    this.m11 - scalar,    this.m12 - scalar,
                this.m20 - scalar,    this.m21 - scalar,    this.m22 - scalar)

public function mat3.op_mult(real scalar) returns mat3
    return mat3(this.m00*scalar,    this.m01*scalar,    this.m02*scalar,
                this.m10*scalar,    this.m11*scalar,    this.m12*scalar,
                this.m20*scalar,    this.m21*scalar,    this.m22*scalar)

public function real.op_mult(mat3 m) returns mat3
    return m*this

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function mat3.op_mult(vec3 v) returns vec3
    return vec3(this.m00*v.x + this.m01*v.y + this.m02*v.z,
                this.m10*v.x + this.m11*v.y + this.m12*v.z,
                this.m20*v.x + this.m21*v.y + this.m22*v.z)

public function vec3.op_mult(mat3 m) returns vec3
    return vec3(this.x*m.m00 + this.y*m.m10 + this.z*m.m20,
                this.x*m.m01 + this.y*m.m11 + this.z*m.m21,
                this.x*m.m02 + this.y*m.m12 + this.z*m.m22)

public function mat3.op_mult(mat3 m) returns mat3
    // row by row
    return mat3(this.m00*m.m00 + this.m01*m.m10 + this.m02*m.m20,
                this.m00*m.m01 + this.m01*m.m11 + this.m02*m.m21,
                this.m00*m.m02 + this.m01*m.m12 + this.m02*m.m22,

                this.m10*m.m00 + this.m11*m.m10 + this.m12*m.m20,
                this.m10*m.m01 + this.m11*m.m11 + this.m12*m.m21,
                this.m10*m.m02 + this.m11*m.m12 + this.m12*m.m22,

                this.m20*m.m00 + this.m21*m.m10 + this.m22*m.m20,
                this.m20*m.m01 + this.m21*m.m11 + this.m22*m.m21,
                this.m20*m.m02 + this.m21*m.m12 + this.m22*m.m22)
    
/** Returns matrix' column by id as a vector or zero-vector if doesn't exist. */
public function mat3.col(int id) returns vec3
    vec3 result
    switch id
        case 0
            result = vec3(this.m00, this.m10, this.m20)
        case 1
            result = vec3(this.m01, this.m11, this.m21)
        case 2
            result = vec3(this.m02, this.m12, this.m22)
        default
            result = ZERO3
    return result

/** Returns matrix' row by id as a vector or zero-vector if doesn't exist. */
public function mat3.row(int id) returns vec3
    vec3 result
    switch id
        case 0
            result = vec3(this.m00, this.m01, this.m02)
        case 1
            result = vec3(this.m10, this.m11, this.m12)
        case 2
            result = vec3(this.m20, this.m21, this.m22)
        default
            result = ZERO3
    return result
        
public function mat3.determinant() returns real
    return this.m00*(this.m11*this.m22 - this.m12*this.m21)
         - this.m01*(this.m10*this.m22 - this.m12*this.m20)
         + this.m02*(this.m10*this.m21 - this.m11*this.m20)

/** Flips the matrix over its main diagonale.
Result of transposing for rotation matrix is its inverse matrix. */
public function mat3.transpose() returns mat3
    return mat3(this.m00,   this.m10,   this.m20,
                this.m01,   this.m11,   this.m21,
                this.m02,   this.m12,   this.m22)

/** Finds inverse matrix.
Returns tuple inverseresult33(bool success, mat3 matrix) where 'success' is true if the inverse matrix exists and 'matrix' is the inverse matrix.
If there's no inverse matrix 'success' is false and 'matrix' is zero matrix. */
public function mat3.inverse() returns inverseresult33
    let d = this.determinant()
    var inverse = inverseresult33(false, ZERO33)
    if d.abs().isBetween(0.998, 1.002)
        inverse.matrix = this.transpose()
    else if d.abs() > 0.002
        let tmp = mat3( this.m11*this.m22 - this.m12*this.m21,
                        this.m02*this.m21 - this.m01*this.m22,
                        this.m01*this.m12 - this.m02*this.m11,
        
                        this.m12*this.m20 - this.m10*this.m22,
                        this.m00*this.m22 - this.m20*this.m02,
                        this.m02*this.m10 - this.m00*this.m12,

                        this.m10*this.m21 - this.m11*this.m20,
                        this.m01*this.m20 - this.m00*this.m21,
                        this.m00*this.m11 - this.m01*this.m10)
        inverse.matrix = 1/d*tmp
    return inverse

/** Extracts Euler-angles (Tait-Bryan) from rotation matrix. Order of result angles is X-Y-Z.*/
public function mat3.toEuler() returns vec3
    real yaw
    real pitch = Asin(this.m02)
    real roll
    var cosY = Cos(pitch)
    if cosY.abs() > 0.005
        var cosX = this.m22/cosY
        var sinX = -this.m12/cosY
        yaw  = Atan2(sinX, cosX)
        var cosZ =  this.m00/cosY
        var sinZ = -this.m01/cosY
        roll = Atan2(sinZ, cosZ)
    else
        yaw = 0.
        var cosZ = this.m11
        var sinZ = this.m10
        roll  = Atan2(sinZ, cosZ) 
    return vec3(yaw, pitch, roll)

public function mat3.toString() returns string
    return "Matrix 3x3\n{0} {1} {2}\n{3} {4} {5}\n{6} {7} {8}".format(
        this.m00.toString(), this.m01.toString(), this.m02.toString(),
        this.m10.toString(), this.m11.toString(), this.m12.toString(),
        this.m20.toString(), this.m21.toString(), this.m22.toString())

/** Creates 3x3 rotation matrix from axis and angle. */
public function vec3.toMatrix(angle angl) returns mat3
    var v = this.norm()
    var x = v.x
    var y = v.y
    var z = v.z
    var mcos = 1 - angl.cos()
    var sin = angl.sin()
    return mat3(1 + mcos*(x*x - 1),    -z*sin + mcos*x*y,     y*sin + mcos*x*z,
                z*sin + mcos*x*y,      1 + mcos*(y*y - 1),    -x*sin + mcos*y*z,
                -y*sin + mcos*x*z,     x*sin + mcos*y*z,      1 + mcos*(z*z - 1))

/** Creates 3x3 rotation matrix from axis and angle. */
public function angle.toMatrix(vec3 axis) returns mat3
    return axis.toMatrix(this)

/** Creates scaling 3x3 matrix from a vector. */
public function vec3.toScaling() returns mat3
    return mat3(this.x, 0,      0,
                0,      this.y, 0,
                0,      0,      this.z)
        


function test22()
    print("=============== Matrix 2x2 testing ===============\n")
    var matrix = mat2( 1, 2,
                    3, 4)
    print("Base {0}\n".format(matrix.toString()))
    // Determinant.
    print("Determinant is {0}\n".format(matrix.determinant().toString()))
    // Inverse.
    var inverse = matrix.inverse()
    print("Inverse matrix exists: {0}\n".format((inverse.success.toString())))
    print("Inverse {0}\n".format(inverse.matrix.toString()))
    // Inverse from inverse.
    var inverseBack = inverse.matrix.inverse()
    print("Inverse from inverse matrix (base expected): {0}\n".format(inverseBack.matrix.toString()))
    // Test inverse matrix
    var mult = matrix*inverse.matrix
    print("Base * Inverse (indetity expected) Result: {0}\n".format((mult.toString())))
    // Get columns
    print("Columns by id (-1, 0, 1, 2):")
    for i=-1 to 2
        print(matrix.col(i).toString())
    // Get rows
    print("\nRows by id (-1, 0, 1, 2):")
    for i=-1 to 2
        print(matrix.row(i).toString())
    // Transpose
    print("\nTranspose {0}\n".format(matrix.transpose().toString()))
    // + itself
    print("Matrix + Matrix = {0}\n".format((matrix + matrix).toString()))
    // - itself
    print("Matrix - Matrix = {0}\n".format((matrix - matrix).toString()))
    // * itself
    print("Matrix * Matrix = {0}\n".format((matrix*matrix).toString()))
    // * scalar
    let scalar = 15.
    print("Matrix * {0} = {1}\n".format(scalar.toString(), (matrix*scalar).toString()))
    // Scaling matrix
    let v = vec2(0.5, 0.25)
    print("{0} to scaling {1}\n".format(v.toString(), v.toScaling().toString()))
    // Rotation
    let a = angle(45*DEGTORAD)
    print("Rotation by {0} degrees is {1}\n".format(a.degrees().toString(), a.toMatrix().toString()))


function test33()
    print("=============== Matrix 3x3 testing ===============\n")
    var matrix = mat3(  1, 2, 3,
                        4, 5, 6,
                        7, 8, 9)
    print("Base {0}\n".format(matrix.toString()))
    // Determinant
    print("Determinant is {0}\n".format(matrix.determinant().toString()))
    // Inverse
    var inverse = matrix.inverse()
    print("Inverse matrix exists: {0}\n".format((inverse.success.toString())))
    // Doesnt exist then new one
    var tmp = mat3( 10, 2, 3,
                    4, 5, 6,
                    7, 8, 9)
    print("Try another {0}\n".format(tmp.toString()))
    inverse = tmp.inverse()
    print("Inverse matrix exists: {0}\n".format((inverse.success.toString())))
    // Inverse once again
    print("Inverse {0}\n".format(inverse.matrix.toString()))
    // Inverse
    var inverseBack = inverse.matrix.inverse()
    print("Inverse from inverse matrix (base expected): {0}\n".format(inverseBack.matrix.toString()))
    // Test inverse matrix
    var mult = tmp*inverse.matrix
    print("Base * Inverse (indetity expected) Result: {0}\n".format((mult.toString())))
    // Return to base matrix
    print("Return to base {0}\n".format(matrix.toString()))
    // Get columns
    print("Columns by id (-1, 0, 1, 2, 3):")
    for i=-1 to 3
        print(matrix.col(i).toString())
    // Get rows
    print("\nRows by id (-1, 0, 1, 2, 3):")
    for i=-1 to 3
        print(matrix.row(i).toString())
    // Transpose
    print("\nTranspose {0}\n".format(matrix.transpose().toString()))
    // + itself
    print("Matrix + Matrix = {0}\n".format((matrix + matrix).toString()))
    // - itself
    print("Matrix - Matrix = {0}\n".format((matrix - matrix).toString()))
    // * itself
    print("Matrix * Matrix = {0}\n".format((matrix*matrix).toString()))
    // * scalar
    let scalar = 15.
    print("Matrix * {0} = {1}\n".format(scalar.toString(), (matrix*scalar).toString()))
    // Scaling matrix
    let v = vec3(0.5, 0.25, 0.75)
    print("{0} to scaling {1}\n".format(v.toString(), v.toScaling().toString()))
    // Rotation
    let axis = vec3(1, 0, 0)
    let a = angle(90*DEGTORAD)
    let rotation = axis.toMatrix(a)
    print("Rotation around {0} by {1} degrees is rotation {2}\n".format(axis.toString(), a.degrees().toString(), rotation.toString()))
    // To Euler angles
    // Cannot produce this tests bcz Asin is not implemented yet.
    let euler = rotation.toEuler()
    print("Found rotation matrix to Euler angles {0}".format(euler.toString()))
    

@test
function test()
    test22()
    test33()
