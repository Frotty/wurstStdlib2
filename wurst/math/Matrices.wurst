package Matrices
import NoWurst
import Vectors
import String


/* Great thanks to euclideanspace.com for wide explanations. */


public let ZERO22 = matrix2(0, 0, 0, 0)
public let ZERO33 = matrix3(0, 0, 0, 0, 0, 0, 0, 0, 0)

public let IDENTITY22 = matrix2(
    1, 0,
    0, 1)

public let IDENTITY33 = matrix3(
    1, 0, 0,
    0, 1, 0,
    0, 0, 1)


/* =========== 2X2 MATRIX =========== */
/** Matrxi 2x2
00 01
10 11
*/
public tuple matrix2(real rc00, real rc01,
                     real rc10, real rc11)

                     
public function matrix2.op_plus(matrix2 m) returns matrix2
    return matrix2(
        this.rc00 + m.rc00, this.rc01 + m.rc01,
        this.rc10 + m.rc10, this.rc11 + m.rc11)

public function matrix2.op_minus(matrix2 m) returns matrix2
    return matrix2(
        this.rc00 - m.rc00, this.rc01 - m.rc01,
        this.rc10 - m.rc10, this.rc11 - m.rc11)

public function matrix2.op_minus(real scalar) returns matrix2
    return matrix2(
        this.rc00 - scalar, this.rc01 - scalar,
        this.rc10 - scalar, this.rc11 - scalar)

public function matrix2.op_plus(real scalar) returns matrix2
    return matrix2(
        this.rc00 + scalar, this.rc01 + scalar,
        this.rc10 + scalar, this.rc11 + scalar)
    
public function matrix2.op_mult(real scalar) returns matrix2
    return matrix2(
        this.rc00*scalar, this.rc01*scalar,
        this.rc10*scalar, this.rc11*scalar)

public function real.op_mult(matrix2 m) returns matrix2
    return m*this

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function matrix2.op_mult(vec2 v) returns vec2
    return vec2(this.rc00*v.x + this.rc01*v.y, this.rc10*v.x + this.rc11*v.y)

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function vec2.op_mult(matrix2 m) returns vec2
    return vec2(this.x*m.rc00 + this.y*m.rc10, this.x*m.rc01 + this.y*m.rc11)

public function matrix2.op_mult(matrix2 m) returns matrix2
    return matrix2(
        this.rc00*m.rc00 + this.rc01*m.rc10, this.rc00*m.rc01 + this.rc01*m.rc11, 
        this.rc10*m.rc00 + this.rc11*m.rc10, this.rc10*m.rc01 + this.rc11*m.rc11)

/** Returns matrix' column by id as a vector or zero-vector if doesn't exist. */
public function matrix2.col(int id) returns vec2
    switch id
        case 0
            return vec2(this.rc00, this.rc10)
        case 1
            return vec2(this.rc01, this.rc11)
        default
            return ZERO2

/** Returns matrix' row by id as a vector or zero-vector if doesn't exist. */
public function matrix2.row(int id) returns vec2
    switch id
        case 0
            return vec2(this.rc00, this.rc01)
        case 1
            return vec2(this.rc10, this.rc11)
        default
            return ZERO2

public function matrix2.rotate(angle angl) returns matrix2
    return angl.toMatrix()*this

public function matrix2.determinant() returns real
    return this.rc00*this.rc11 - this.rc01*this.rc10

public function matrix2.transpose() returns matrix2
    return matrix2(
        this.rc00, this.rc10,
        this.rc01, this.rc11)

/** Returns a zero-matrix in case there's no inverse matrix.*/
public function matrix2.inverse() returns matrix2
    var d = this.determinant()
    if d.abs().isBetween(0.998, 1.002)
        return this.transpose()
    else if d.abs() > 0.002
        var m = matrix2(
            this.rc11, -this.rc01,
            -this.rc10, this.rc00)
        return 1/d*m
    return ZERO22

public function matrix2.toString() returns string
    return "Matrix 2x2\n{0} {1}\n{2} {3}".format(
        this.rc00.toString(), this.rc01.toString(),
        this.rc10.toString(), this.rc11.toString())

/** Creates rotation matrix from angle. */
public function angle.toMatrix() returns matrix2
    return matrix2(
        this.cos(), -this.sin(),
        this.sin(), this.cos())

/** Creates scaling 2x2 matrix from a vector. */
public function vec2.toScaling() returns matrix2
    return matrix2(
        this.x, 0,
        0, this.y)
    
/* =========== 3X3 MATRIX =========== */
/** Matrix 3x3
00 01 02
10 11 12
20 21 22
*/
public tuple matrix3(
    real rc00, real rc01, real rc02,
    real rc10, real rc11, real rc12,
    real rc20, real rc21, real rc22)

public function matrix3.op_plus(matrix3 m) returns matrix3
    return matrix3(
        this.rc00 + m.rc00, this.rc01 + m.rc01, this.rc02 + m.rc02,
        this.rc10 + m.rc10, this.rc11 + m.rc11, this.rc12 + m.rc12,
        this.rc20 + m.rc20, this.rc21 + m.rc21, this.rc22 + m.rc22)

public function matrix3.op_plus(real scalar) returns matrix3
    return matrix3(
        this.rc00 + scalar, this.rc01 + scalar, this.rc02 + scalar,
        this.rc10 + scalar, this.rc11 + scalar, this.rc12 + scalar,
        this.rc20 + scalar, this.rc21 + scalar, this.rc22 + scalar)

public function matrix3.op_minus(matrix3 m) returns matrix3
    return matrix3(
        this.rc00 - m.rc00, this.rc01 - m.rc01, this.rc02 - m.rc02,
        this.rc10 - m.rc10, this.rc11 - m.rc11, this.rc12 - m.rc12,
        this.rc20 - m.rc20, this.rc21 - m.rc21, this.rc22 - m.rc22)
        
public function matrix3.op_minus(real scalar) returns matrix3
    return matrix3(
        this.rc00 - scalar, this.rc01 - scalar, this.rc02 - scalar,
        this.rc10 - scalar, this.rc11 - scalar, this.rc12 - scalar,
        this.rc20 - scalar, this.rc21 - scalar, this.rc22 - scalar)

public function matrix3.op_mult(real scalar) returns matrix3
    return matrix3(
        this.rc00*scalar, this.rc01*scalar, this.rc02*scalar,
        this.rc10*scalar, this.rc11*scalar, this.rc12*scalar,
        this.rc20*scalar, this.rc21*scalar, this.rc22*scalar)

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function real.op_mult(matrix3 m) returns matrix3
    return m*this

/** Matrix multiplication is not commutative that means matrix*vect is not the same as vec*matrix. */
public function matrix3.op_mult(vec3 v) returns vec3
    return vec3(
        this.rc00*v.x + this.rc01*v.y + this.rc02*v.z,
        this.rc10*v.x + this.rc11*v.y + this.rc12*v.z,
        this.rc20*v.x + this.rc21*v.y + this.rc22*v.z)

public function vec3.op_mult(matrix3 m) returns vec3
    return vec3(
        this.x*m.rc00 + this.y*m.rc10 + this.z*m.rc20,
        this.x*m.rc01 + this.y*m.rc11 + this.z*m.rc21,
        this.x*m.rc02 + this.y*m.rc12 + this.z*m.rc22)

public function matrix3.op_mult(matrix3 m) returns matrix3
    // row by row
    return matrix3(
        this.rc00*m.rc00 + this.rc01*m.rc10 + this.rc02*m.rc20,
        this.rc00*m.rc01 + this.rc01*m.rc11 + this.rc02*m.rc21,
        this.rc00*m.rc02 + this.rc01*m.rc12 + this.rc02*m.rc22,

        this.rc10*m.rc00 + this.rc11*m.rc10 + this.rc12*m.rc20,
        this.rc10*m.rc01 + this.rc11*m.rc11 + this.rc12*m.rc21,
        this.rc10*m.rc02 + this.rc11*m.rc12 + this.rc12*m.rc22,

        this.rc20*m.rc00 + this.rc21*m.rc10 + this.rc22*m.rc20,
        this.rc20*m.rc01 + this.rc21*m.rc11 + this.rc22*m.rc21,
        this.rc20*m.rc02 + this.rc21*m.rc12 + this.rc22*m.rc22)
    
/** Returns matrix' column by id as a vector or zero-vector if doesn't exist. */
public function matrix3.col(int id) returns vec3
    switch id
        case 0
            return vec3(this.rc00, this.rc10, this.rc20)
        case 1
            return vec3(this.rc01, this.rc11, this.rc21)
        case 2
            return vec3(this.rc02, this.rc12, this.rc22)
        default
            return ZERO3

/** Returns matrix' row by id as a vector or zero-vector if doesn't exist. */
public function matrix3.row(int id) returns vec3
    switch id
        case 0
            return vec3(this.rc00, this.rc01, this.rc02)
        case 1
            return vec3(this.rc10, this.rc11, this.rc12)
        case 2
            return vec3(this.rc20, this.rc21, this.rc22)
        default
            return ZERO3
        
public function matrix3.determinant() returns real
    return this.rc00*(this.rc11*this.rc22 - this.rc12*this.rc21)
         - this.rc01*(this.rc10*this.rc22 - this.rc12*this.rc20)
         + this.rc02*(this.rc10*this.rc21 - this.rc11*this.rc20)

public function matrix3.transpose() returns matrix3
    return matrix3(
        this.rc00, this.rc10, this.rc20,
        this.rc01, this.rc11, this.rc21,
        this.rc02, this.rc12, this.rc22)

/** Returns a zero-matrix in case there's no iverse matrix.*/
public function matrix3.inverse() returns matrix3
    var d = this.determinant()
    if d.abs().isBetween(0.998, 1.002)
        return this.transpose()
    else if d.abs() > 0.002
        return 1/d*matrix3(
            this.rc11*this.rc22 - this.rc12*this.rc21,
            this.rc02*this.rc21 - this.rc01*this.rc22,
            this.rc01*this.rc12 - this.rc02*this.rc11,
        
            this.rc12*this.rc20 - this.rc10*this.rc22,
            this.rc00*this.rc22 - this.rc20*this.rc02,
            this.rc02*this.rc10 - this.rc00*this.rc12,

            this.rc10*this.rc21 - this.rc11*this.rc20,
            this.rc01*this.rc20 - this.rc00*this.rc21,
            this.rc00*this.rc11 - this.rc01*this.rc10)
    return ZERO33

public function matrix3.toEuler() returns vec3
    real yaw
    real pitch = Asin(this.rc02)
    real roll
    var cosY = Cos(pitch)
    if cosY.abs() > 0.005
        var cosX = this.rc22/cosY
        var sinX = -this.rc12/cosY
        yaw  = Atan2(sinX, cosX)
        var cosZ =  this.rc00/cosY
        var sinZ = -this.rc01/cosY
        roll = Atan2(sinZ, cosZ)
    else
        yaw = 0.
        var cosZ = this.rc11
        var sinZ = this.rc10
        roll  = Atan2(sinZ, cosZ) 
    return vec3(yaw, pitch, roll)

public function matrix3.toString() returns string
    return "Matrix 3x3\n{0} {1} {2}\n{3} {4} {5}\n{6} {7} {8}".format(
        this.rc00.toString(), this.rc01.toString(), this.rc02.toString(),
        this.rc10.toString(), this.rc11.toString(), this.rc12.toString(),
        this.rc20.toString(), this.rc21.toString(), this.rc22.toString())

/** Creates 3x3 rotation matrix from axis and angle. */
public function vec3.toMatrix(angle angl) returns matrix3
    var v = this.norm()
    var x = v.x
    var y = v.y
    var z = v.z
    var cos = angl.cos()
    var sin = angl.sin()
    return matrix3(
        1 + (1 - cos)*(x*x - 1), -z*sin+ (1 - cos)*x*y, y*sin+ (1 - cos)*x*z,
        z*sin+ (1 - cos)*x*y, 1 + (1 - cos)*(y*y - 1), -x*sin+ (1 - cos)*y*z,
        -y*sin+ (1 - cos)*x*z, x*sin+ (1 - cos)*y*z, 1 + (1 - cos)*(z*z - 1))

/** Creates 3x3 rotation matrix from axis and angle. */
public function angle.toMatrix(vec3 axis) returns matrix3
    return axis.toMatrix(this)

/** Creates scaling 3x3 matrix from a vector. */
public function vec3.toScaling() returns matrix3
    return matrix3(
        this.x, 0, 0,
        0, this.y, 0,
        0, 0, this.z)
        
