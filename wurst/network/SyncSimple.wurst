package SyncSimple
import LinkedList
import ChunkedString

/* 	Simple String syncing for Patches 1.31 and up with chunked string support for big data.
	For improved safety, sync operations are performed sequentially - one string/chunk at a time.

	Sync a string:
	>	myString.sync(p) (synced) ->
	>		Log.info("string synced: " + synced.getUnsafeString())

	Sync a ChunkedString:
	>	myChunkedString.sync(p) (synced) ->
	>		while synced.hasChunk()
	>			Log.info("chunked string synced: " + synced.readChunk())

	Sync a ChunkedString with monitor:
	>	let monitor = myChunkedString.syncWithMonitor(p) (synced) ->
	>		while synced.hasChunk()
	>			Log.info("chunked string synced: " + synced.readChunk())
	>	// another thread
	> 	if monitor.cancel()
	>		Log.info("chunked string sync is cancelled, the message in the code above won't display")
	>	destroy monitor // don't forget to destroy the monitor when you're no longer interested in the state of the operation

*/

@configurable public constant DEFAULT_PREFIX = "S"
@configurable public constant LAST_CHUNK_PREFIX = "T"

public interface StringSyncListener
	function onDataSynced(string data)

public interface BufferSyncListener
	function onDataSynced(ChunkedString buffer)

constant syncQueue = new LinkedList<SyncData>

/** Syncs a single string from the given player. */
public function string.sync(player p, StringSyncListener listener)
	syncQueue.add(new SyncData(p, listener, this))

	if syncQueue.size() == 1
		checkQueue()

/** Syncs a chunked string from the given player. */
public function ChunkedString.sync(player p, BufferSyncListener listener)
	syncQueue.add(new SyncData(p, listener, this))

	if syncQueue.size() == 1
		checkQueue()

/** Syncs a chunked string from the given player.
	The returned monitor allows to track the operation's state, 
	cancel it and set an on-progress-change listener. */
public function ChunkedString.syncWithMonitor(player p, BufferSyncListener listener) returns SyncMonitor
	let monitor = new SyncMonitor()
	monitor.done = false
	let data = new SyncData(p, listener, this)
	monitor.data = data
	data.monitor = monitor
	data.max = this.getChunkCount()
	syncQueue.add(data)

	if syncQueue.size() == 1
		checkQueue()

	return monitor

public interface SyncProgressListener
	function onProgressChange(int current, int max)

public class SyncMonitor

	protected SyncData data = null
	protected var done = true
	protected var cancelled = false

	ondestroy
		if data != null
			data.monitor = null

	/** Tries to cancel the operation. Returns 'false' if the operation is already done.
		If this method returns 'true', the operation listener was not and will not be called. */
	function cancel() returns bool
		if done
			return false
		cancelled = true
		return true

	/** Returns whether the operation has been cancelled. */
	function isCancelled() returns bool
		return cancelled

	/** Returns whether the operation has finished and the operation listener was called. */
	function isDone() returns bool
		return done

	/** Returns whether the operation has finished - either if it was done or cancelled. */
	function isFinished() returns bool
		return done or cancelled

	/** Sets the callback to be called each time when a part of the data is synced.
		You have to set the callback before exiting the thread where you've started the operation.
		Due to the fact that in Wc3 there is only one thread working at a time,
		it will work correctly and no update would be skipped. */
	function onProgressChange(SyncProgressListener listener)
		if data == null
			return
		if data.plistener != null
			destroy data.plistener
		data.plistener = listener

class SyncData
	StringSyncListener slistener = null
	BufferSyncListener blistener = null
	player syncer = null
	string data = null
	ChunkedString buffer = null
	ChunkedString syncBuffer = null
	SyncMonitor monitor = null
	SyncProgressListener plistener = null
	var current = 0
	var max = 0

	construct(player syncer, StringSyncListener slistener, string data)
		this.slistener = slistener
		this.data = data
		this.syncer = syncer

	construct(player syncer, BufferSyncListener blistener, ChunkedString data)
		this.blistener = blistener
		this.buffer = data
		this.syncer = syncer
		this.syncBuffer = new ChunkedString()

	ondestroy
		if monitor != null
			monitor.data = null
		if plistener != null
			destroy plistener
		if slistener != null
			destroy slistener
		if blistener != null
			destroy blistener
		if buffer != null
			destroy buffer

	function increaseProgress(int delta)
		current += delta
		if plistener != null
			plistener.onProgressChange(current, max)

function checkQueue()
	if not syncQueue.isEmpty()
		let syncData = syncQueue.getFirst()
		if syncData.data != null
			if localPlayer == syncData.syncer
				BlzSendSyncData(DEFAULT_PREFIX, syncData.data)
		else
			let data = syncData.buffer.readChunk()
			let hasChunk = syncData.buffer.hasChunk()
			if localPlayer == syncData.syncer
				if hasChunk
					BlzSendSyncData(DEFAULT_PREFIX, data)
				else
					BlzSendSyncData(LAST_CHUNK_PREFIX, data)

init
	let trig = CreateTrigger()
	for i = 0 to bj_MAX_PLAYER_SLOTS - 1
		BlzTriggerRegisterPlayerSyncEvent(trig, players[i], DEFAULT_PREFIX, false)
		BlzTriggerRegisterPlayerSyncEvent(trig, players[i], LAST_CHUNK_PREFIX, false)

	trig.addAction() ->
		let eventData = BlzGetTriggerSyncData()
		let eventPrefix = BlzGetTriggerSyncPrefix()
		let syncData = syncQueue.getFirst()
		if syncData.data != null
			syncData.slistener.onDataSynced(eventData)
			syncQueue.dequeue()
			destroy syncData
		else if syncData.monitor == null or not syncData.monitor.cancelled
			syncData.increaseProgress(1)
			syncData.syncBuffer.append(eventData)
			if eventPrefix == LAST_CHUNK_PREFIX
				if syncData.monitor != null
					syncData.monitor.done = true
				syncData.blistener.onDataSynced(syncData.syncBuffer)
				syncQueue.dequeue()
				destroy syncData
		else // cancelled
			syncQueue.dequeue()
			destroy syncData
		checkQueue()
