package SyncSimple

import UnitIndexer
import BitSet
import LinkedListModule
import RegisterEvents

/********************************************************************************
	SyncSimple library by MoriMori.

	Based on TriggerHappy's SyncInteger library.

	Rationale:
		This library can be used to send a 'synchronize' network event that will fire
		for all players after all previous network events have also been received
		by all players.
		Examples of such events include:
			- Unit selection
			- Unit orders
			- Chat messages
			- Gamecache synchronization
			- Keyboard events
		
		For example, this can be used in conjunction with gamecache synchronization
		to send 'local' values from one player to the rest, such as camera position,
		data from files, and so on. For a package implementing this functionality,
		see Network. 

		It depends on the fact that all network events in WC3 are fired sequentially,
		meaning that they arrrive for other players in the order that they were
		sent in.
		It also depends on the fact that the EVENT_PLAYER_UNIT_SELECTED fires
		synchronously for all players at the same time, allowing us to know for
		certain when other players have acknowledged our unit selection, as well
		as all network events that have been fired before it.

		By calling the .sync() method, we queue a network action (specifically,
		a unit selection event) that will only be delivered after all previously 
		queued network actions have also been delivered.
		The primary use of this library is in conjunction with gamecache's Sync
		natives, because they also fire sequential network events. When we call
		.sync() after a series of Sync natives, we ensure that the .onSynced()
		callback will only be called after all players have received the data.

		This way, we can send local data from one player to the rest, such as
		camera position, data from files, and so on.

		There may be other usages related to async network events as well.

	Usage:
		1. Create a new SimpleSynchronizer using:
			let synchronizer = new SimpleSynchronizer()

		2. Send some network events on one (or more) player using the Sync natives (or something else)
			if sender == localPlayer
				// value1 and value2 are some local values only known to localPlayer
				SyncStoredInteger(gc, mkey, vkey1, value1)
				SyncStoredInteger(gc, mkey, vkey1, value1)
		
		3. Set a callback to be called after all players have synchronized and read the data
			synchronizer.onSynced(() -> begin
				let value1 = LoadInteger(gc, mkey, vkey1)
				let value2 = LoadInteger(gc, mkey, vkey2)

				// here, value1 and value2 are integers received from sender
				...
			end)

		4. Call .sync() on all game clients, after having called the Sync natives.
			synchronizer.sync()

		5. A SimpleSynchronizer can only be used once, and gets destroyed automatically after all players have synced.
		To synchronize again, create a new SimpleSynchronizer
			
********************************************************************************/

// briefly selects the specified unit by the player
function player.onceSelect(unit what)
	ENUM_GROUP.enumUnitsSelected(this, null)
	unit last = null
	var count = 0
	for selected in ENUM_GROUP
		count++
		last = selected

	if count >= 12
		this.unselect(last)

	if localPlayer == this
		this.select(what)
		this.unselect(what)

	if count >= 12
		this.select(last)

	ENUM_GROUP.destr()
	
public interface SynchronizationCallback
	function onSynchronized()

public class SimpleSynchronizer
	use LinkedListModule

	private static constant player  DUMMY_PLAYER = players[PLAYER_NEUTRAL_PASSIVE]
	private static constant integer DUMMY_ID     = 'hfoo'
	private static constant integer DUMMY_GHOST  = 'Aeth'
	private static thistype array reverseLookup

	private unit dummy
	private bitset syncedPlayers = emptyBitset()
	// 4095 is 1111 1111 1111 in binary, one bit for each player slot
	private static bitset allPlayers = bitset(4095)
	private SynchronizationCallback callback = null

	construct()
		dummy = CreateUnit(DUMMY_PLAYER, DUMMY_ID, 0, 0, 0)
		..addAbility(DUMMY_GHOST)
		..pause()
		..setScale(0)
		reverseLookup[dummy.getIndex()] = this

	ondestroy
		reverseLookup[dummy.getIndex()] = null
		dummy.remove()

	/**
		Signals that the local player is ready to continue.
	**/
	function sync()
		addOfflinePlayers()
		localPlayer.onceSelect(dummy)

	/**
		Calls the callback when all players have called sync()
	**/
	function onSynced(SynchronizationCallback callback)
		this.callback = callback

	private function addOfflinePlayers()
		for i = 0 to 11
			if not players[i].isIngame()
				syncedPlayers = syncedPlayers.add(i)

	private function areAllPlayersSynced() returns boolean
		return syncedPlayers == allPlayers

	private function onPlayerFinishedSync(player who)
		syncedPlayers = syncedPlayers.add(who.getId())

		if areAllPlayersSynced()
			callback.onSynchronized()

			destroy this

	private function onPlayerLeave(player who)
		onPlayerFinishedSync(who)

	private static function getSynchronizer(unit what) returns thistype
		return reverseLookup[what.getIndex()]

	protected static function onInit()
		registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SELECTED, null, null, () -> begin
			let synchronizer = getSynchronizer(GetTriggerUnit())

			if synchronizer != null
				synchronizer.onPlayerFinishedSync(GetTriggerPlayer())
		end)

		registerPlayerEvent(EVENT_PLAYER_LEAVE, () -> begin
			let who = GetTriggerPlayer()

			for synchronizer in SimpleSynchronizer
				synchronizer.onPlayerLeave(who)
		end)
		
init
	SimpleSynchronizer.onInit()
