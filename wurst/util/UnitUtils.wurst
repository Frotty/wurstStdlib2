package UnitUtils
import BuffObjEditing
import ClosureTimers



/*	This file contains various utility functions for Unit, 
	which require enhanced functionality like closures and cannot be defined in Unit.wurst */

@configurable public real FIELD_OF_VIEW_FRONT  = 230.00
@configurable public real FIELD_OF_VIEW_BEHIND = 115.00  // Real FoV is: 180 - 2x (FIELD_OF_VIEW-90)	Using a value of 115 generates a FoV of 130   (natural FoV is about 135 degrees)

/** Apply Buff to this unit for duration.*/
public function unit.applyBuffTimed(buffTuple buffApplied, real duration)
	this.addAbility(buffApplied.abilId)
	this.setAbilityLevel(buffApplied.abilId, 1)
	doAfter(duration) ->
		if this != null
			this.setAbilityLevel(buffApplied.abilId, 0)
			this.removeAbility(buffApplied.abilId)
			
/** Increase Armor of a unit for a duration */
public function unit.addArmorTimed(real armorAdd, real duration)
	BlzSetUnitArmor(this, this.getArmor()+armorAdd)
	doAfter(duration) ->
		if this != null
			BlzSetUnitArmor(this, this.getArmor()-armorAdd)
			
/** Increase Damage of a unit for a duration */		
public function unit.addDamageTimed(int damageAdd, real duration)
	BlzSetUnitBaseDamage(this, this.getBaseDamage(1)+damageAdd, 1)
	doAfter(duration) ->
		if this != null
			BlzSetUnitBaseDamage(this, this.getBaseDamage(1)-damageAdd, 1)

/** Make unit take DMG over time for given duration with hard-coded interval of 1s so dmg per seconds as input*/
public function unit.applyDOTTimedFrom(unit damagingUnit, real duration, real dotDamage, buffTuple buffApplied)
	this.applyDOTTimedFrom(damagingUnit, duration, 1, dotDamage, buffApplied)

/** Make unit take DMG over time for given duration.*/
public function unit.applyDOTTimedFrom(unit damagingUnit, real duration, real interval, real dotDamage, buffTuple buffApplied)
	if this != null and this.isAlive()
		this.addAbility(buffApplied.abilId)
		this.setAbilityLevel(buffApplied.abilId, 1)

		let targetUnit = this // saveback for closure
		doPeriodicallyCounted(interval,  (duration/interval).floor()+1) cb ->
			if targetUnit == null or not targetUnit.isAlive() or cb.isLast()
				targetUnit.setAbilityLevel(buffApplied.abilId, 0)
				targetUnit.removeAbility(buffApplied.abilId)
				destroy cb
			else
				if damagingUnit == null
					targetUnit.damageTarget(targetUnit, dotDamage)
				else
					damagingUnit.damageTarget(targetUnit, dotDamage)
					
/** Make unit take mana and HP HEAL over time for given duration.*/
public function unit.restoreHpMpTimed(real duration, real interval, real hotVal, real motVal, buffTuple buffApplied)
	if this != null and this.isAlive()
		this.addAbility(buffApplied.abilId)
		this.setAbilityLevel(buffApplied.abilId, 1)

		let targetUnit = this // saveback for closure
		let maxCount   = (duration/interval).floor()+1	  //  last proc are is cut off 
		doPeriodicallyCounted(interval, maxCount) cb ->	 // first proc will be applied after 1*interval
			if targetUnit == null or not targetUnit.isAlive() or cb.isLast()
				targetUnit.setAbilityLevel(buffApplied.abilId, 0)
				targetUnit.removeAbility(buffApplied.abilId)
				destroy cb
			else 
				if hotVal >= 1
					this.setHP(this.getHP()+hotVal)
				if motVal >= 1
					this.setMana(this.getMana()+motVal)
					
/** Plays a unit animation for a specifc amount of time.
	Duration of -1 == endless animation. */
public function unit.playAnimation(string anim, real duration)
	SetUnitAnimation(this, anim)
	if duration != -1
		doAfter(duration) ->
			ResetUnitAnimation(this)

public class OnFinishUnitAnimation
	unit u = null
	construct(unit u)
		this.u = u
	function onFinish()
		if this.u != null
			ResetUnitAnimation(u)

/** plays a unit animation until a specific callback is called */
public function unit.playAnimation(string anim) returns OnFinishUnitAnimation
	SetUnitAnimation(this, anim)
	return new OnFinishUnitAnimation(this)

/** Returns true if this unit is behind target unit.
    Uses configurable FIELD_OF_VIEW_BEHIND variable with default value of 115. */
public function unit.isBehind(unit targetUnit) returns bool
	let degreeDif = this.getFacingAngle().degrees() - targetUnit.getFacingAngle().degrees()
	return -FIELD_OF_VIEW_BEHIND <= degreeDif and degreeDif <= FIELD_OF_VIEW_BEHIND

/** Returns true if this unit is in front of target unit.
	Uses configurable FIELD_OF_VIEW_FRONT variable with default value of 230. */
public function unit.isInFront(unit targetUnit) returns bool
	let degreeDif = this.getFacingAngle().degrees() - targetUnit.getFacingAngle().degrees()
	return -FIELD_OF_VIEW_FRONT <= degreeDif and degreeDif <= FIELD_OF_VIEW_FRONT

/** Change unit attack cooldown by given percentage. */
public function unit.setAttackCooldownPercChange(real attackCooldownPercChange, int weaponIndex) returns real
	let newSpeed = this.getAttackCooldown(weaponIndex)/(1+attackCooldownPercChange)
	this.setAttackCooldown(newSpeed, weaponIndex)
	return newSpeed
   
/** Change unit movement speed by given percentage. */
public function unit.setMoveSpeedPercChange(real movespeedPercChange) returns real
	let newSpeed = this.getMoveSpeed() + (this.getMoveSpeed()*movespeedPercChange)
	this.setMoveSpeed(newSpeed)
	return newSpeed
	