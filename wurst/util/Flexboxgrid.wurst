package Flexboxgrid
import LinkedList
import HashMap

public class FlexboxgridBuilder
	Container c = new Col() // invariant: c != null
	/** Inserts a row, which aligns its contains' height. */
	function row() returns FlexboxgridBuilder
		addContainer(new Row())
		return this
	/** Inserts a column, which aligns its contains' width. */
	function col() returns FlexboxgridBuilder
		addContainer(new Col())
		return this
	/** Inserts a table, which aligns its contains in a grid.
		
		Use `.line()` to go to the next row
		and `.stub()` to skip an element in the row. */
	function table() returns FlexboxgridBuilder
		addContainer(new Table())
		return this

	/** Closes current container (row, col or table) and goes back to it's holder. */
	function close() returns FlexboxgridBuilder
		if c.parent == null
			Log.error("close: Matching container opener not found")
		else
			c = c.parent
		return this
	
	/** Fixes height and relative width of current container
		(by default it's defined by it's contains) */
	function size(real w, int h) returns FlexboxgridBuilder
		c.width_ = w
		c.fixed_w = true
		c.height_ = h
		c.fixed_h = true
		return this

	/** Fixes relative width of current container
		(by default it's defined by it's contains) */
	function width(real w) returns FlexboxgridBuilder
		c.width_ = w
		c.fixed_w = true
		return this
	
	/** Fixes height of current container
		(by default it's defined by it's contains) */
	function height(int h) returns FlexboxgridBuilder
		c.height_ = h
		c.fixed_h = true
		return this

	/** Adds a cell in the container with given parameters. */
	function cell(real width, string value, string icon, colorA clr) returns FlexboxgridBuilder
		addCell(new Cell(width, value, icon, clr))
		return this
	/** Adds a cell in the container with given parameters. */
	function cell(real width, string value, colorA clr) returns FlexboxgridBuilder
		addCell(new Cell(width, value, "", clr))
		return this
	/** Adds a cell in the container with given parameters. */
	function cell(real width, string value) returns FlexboxgridBuilder
		addCell(new Cell(width, value, "", COLOR_WHITE))
		return this
	/** Adds a cell in the container which parameters is defined by `updater`
		through its `.update(Cell)` method. */
	function cell(real width, CellUpdater updater) returns FlexboxgridBuilder
		addCell(new Cell(width, updater))
		return this
	/** Adds an empty space in the container with 0 width and 1 line height.
		Useful in Column or in Table. */
	function stub() returns FlexboxgridBuilder
		addCell(STUB)
		return this

	/** Use to insert new row in the table and switch to it. */
	function line() returns FlexboxgridBuilder
		c.line()
		return this

	function finish() returns Flexboxgrid
		while c.parent != null
			c = c.parent
		let fbx = Flexboxgrid.wrap(c)
		destroy this
		return fbx

	private function addContainer(Container c_)
		c_.parent = c
		c.insert(c_)
		c = c_

	private function addCell(Cell c_)
		c.insert(c_)

public class Flexboxgrid
	protected static function wrap(Container c) returns Flexboxgrid
		return new Flexboxgrid(c)
	private construct(Flex o)
		e = o
		e.calc()
	private multiboard mb = null
	private var width = 0.3
	private Flex e = null
	private let rowItemCount = new HashMap<int, int>

	protected function nextRowItem(int row) returns multiboarditem
		let count = rowItemCount.get(row)
		rowItemCount.put(row, count + 1)
		if count >= mb.getColumnCount()
			mb.setColumnCount(count + 1)
		return mb.getItem(row, count)

	protected function reserveRowNextItems(int row, int itemCount) returns int
		let count = rowItemCount.get(row)
		rowItemCount.put(row, count + itemCount)
		if count + itemCount > mb.getColumnCount()
			mb.setColumnCount(count + itemCount)
		return count

	protected function getItem(int row, int column) returns multiboarditem
		return mb.getItem(row, column)

	function setWidth(real width)
		if width > 0.001
			this.width = width

	function initialize()
		mb = CreateMultiboard()
		..display(false)

	/** This function starts a recursive multiboard update */
	function update()
		e.update()

	function recalculate()
		e.calc()

	function draw()
		mb
		..setItemsStyle(true, false)
		..setItemsWidth(0.01)
		..setItemsValue("!error")
		..setItemsValueColor(255, 0, 0, 255)
		..setRowCount(e.height_)
		rowItemCount.flush()
		
		let t = Flex.cfbx
		Flex.cfbx = this
		e.draw(0, width, e.height_)
		Flex.cfbx = t
		mb..display(true)

	ondestroy
		destroy rowItemCount
		destroy e
		mb.destr()

function multiboarditem.preset(real width, string value, string icon, colorA clr)
	this
	..setStyle(value != "", icon != "")
	..setWidth(width - 0.001)
	..setValue(value)
	..setIcon(icon)
	..setValueColor(clr)
	.release()

abstract class Flex // hello, ricardo
	protected static Flexboxgrid cfbx = null // parent flexboxgrid during draw()
	protected var width_ = 0.
	protected var height_ = 1
	protected var fixed_h = false
	protected var fixed_w = false
	protected abstract function draw(int y, real width_, int height_)
	protected abstract function calc()
	protected abstract function update()

public interface CellUpdater
	function update(Cell c)

constant STUB = new Cell()
public class Cell extends Flex
	var value = ""
	var icon = ""
	var clr = COLOR_WHITE
	var width = 0.
	CellUpdater updater = null

	construct()
	
	construct(real width_, CellUpdater updater_)
		width = width_
		updater = updater_
		update()

	construct(real width_, string value_, string icon_, colorA clr_)
		width = width_
		value = value_
		icon = icon_
		clr = clr_
	
	ondestroy
		destroy updater

	function clear()
		value = ""
		icon = ""
		clr = COLOR_WHITE
		width = 0.

	override function calc()
		height_ = 1
		width_ = width

	override function draw(int y, real width, int height)
		cfbx.nextRowItem(y).preset(width, value, icon, clr)
		var py = y + 1
		while py < y + height
			cfbx.nextRowItem(py).preset(width, "", "", COLOR_WHITE)
			py++

	override function update()
		if updater != null
			updater.update(this)


abstract class Container extends Flex
	Container parent = null
	abstract function insert(Flex o)
	function line()
		Log.error("[Flexboxgrid] called .line() on wrong container type!")

abstract class LinearContainer extends Container
	let objs = new LinkedList<Flex>

	ondestroy
		for o in objs
			destroy o
		destroy objs

	override function insert(Flex o)
		objs.add(o)

	override function update()
		for o in objs
			o.update()

class Row extends LinearContainer
	real sum_width_ = 0.
	override function calc()
		var max_height_ = 1
		sum_width_ = 0
		for o in objs
			o.calc()
			max_height_ = max(max_height_, o.height_)
			sum_width_ += o.width_
		if not fixed_w
			width_ = sum_width_
		if not fixed_h or height_ < max_height_
			height_ = max_height_

	override function draw(int y, real width, int height)
		for o in objs
			o.draw(y, width * o.width_ / sum_width_, height)

class Col extends LinearContainer
	int sum_height_ = 0
	override function calc()
		var max_width_ = 0.
		sum_height_ = 0
		for o in objs
			o.calc()
			max_width_ = max(max_width_, o.width_)
			sum_height_ += o.height_
		if not fixed_w
			width_ = max_width_
		if not fixed_h or height_ < sum_height_
			height_ = sum_height_

	override function draw(int y, real width, int height)
		var py = y
		for o in objs
			o.draw(py, width, o.height_)
			py += o.height_

		while py < y + height
			cfbx.nextRowItem(py).preset(width, "", "", COLOR_WHITE)
			py++

class Table extends Container
	let ls = new LinkedList<LinkedList<Flex>>..add(new LinkedList<Flex>)
	let heights = new LinkedList<int>
	let widths = new LinkedList<real>
	var cols = 0
	real sum_width_ = 0.
	int sum_height_ = 0

	ondestroy
		for l in ls
			for o in l
				destroy o
			destroy l
		destroy ls
		destroy heights
		destroy widths

	override function insert(Flex o)
		ls.peek().add(o)
		if ls.peek().size() > cols
			cols = ls.peek().size()

	override function line()
		ls.add(new LinkedList<Flex>)

	override function update()
		for l in ls
			for o in l
				o.update()

	override function calc()
		sum_height_ = 0
		sum_width_ = 0
		heights.clear()
		widths.clear()
		for l in ls
			int h = 0
			while widths.size() < l.size()
				widths.add(0)
			var i = widths.iterator()
			for o in l
				o.calc()
				h = max(h, o.height_)
				if i.hasNext()
					i.modify(max(i.next(), o.width_))
				else
					widths.add(o.width_)
			i.close()
			heights.add(h)
			sum_height_ += h
		for w in widths
			sum_width_ += w
		if not fixed_h or height_ < sum_height_
			height_ = sum_height_
		if not fixed_w
			width_ = sum_width_

	override function draw(int y, real width, int height)
		var py = y
		var ih = heights.iterator()
		for l in ls
			var iw = widths.iterator()
			ih.next()
			int i = 0
			for o in l
				o.draw(py, width * iw.next() / this.sum_width_, ih.current.elem)
				i++
			while i < cols
				STUB.draw(py, width * iw.next() / this.sum_width_, ih.current.elem)
				i++
			py += ih.current.elem
			iw.close()
		ih.close()
		while py < y + height_
			cfbx.nextRowItem(py).preset(width, "", "", COLOR_WHITE)
			py++
