package Projectile
import NoWurst
import LinkedListModule
import Timer
import Effect
import Interpolation
import Vectors
import Quaternion
import Maths
import Colors

constant EPSILON = 0.0001

public class Projectile
	use LinkedListModule
	protected unit owner = null
	protected effect model = null
	protected var scale = 1.
	protected var timeScale = 1.
	protected var distance = 0.
	protected var speed = 0.
	protected var remain = 0.
	protected var start = ZERO3
	protected var control = ZERO3
	protected var finish = ZERO3
	protected var pos = ZERO3
	protected var prevPos = ZERO3
	protected var orientation = IDENTITYQ
	protected var direction = vec3(1, 0, 0)
	protected var steering = false
	protected var paused = false
	protected var belowTerrain =  true
	protected var clr = COLOR_WHITE

	private static let TIMER = CreateTimer()
	private static let DELAY = 0.02

	/** Do not forget to use proper coords of the points which include terrain's Z and unit's height */
	construct(unit owner, string model, vec3 start, vec3 finish, real speed)
		constructor(owner, model, start, finish, speed)

	/** Do not forget to use proper coords of the points which include terrain's and and unit's height.
	Use 'arc' argument as you do it in the object editor. */
	construct(unit owner, string model, vec3 start, vec3 finish, real arc, real speed)
		constructor(owner, model, start, finish, speed)
		control.z += 2 * start.distanceTo(finish) * arc - 0.5 * finish.z - 0.5 * start.z

	/** 'height' is height of the point through which the projectile will pass in the middle of its path. */
	construct(unit owner, string model, vec3 start, real height, vec3 finish, real speed)
		constructor(owner, model, start, finish, speed)
		control.z += 2 * height - 0.5 * finish.z - 0.5 * start.z

	/** 'mid' is the point through which the projectile will pass in the middle of its path. */
	construct(unit owner, string model, vec3 start, vec3 mid, vec3 finish, real speed)
		constructor(owner, model, start, finish, speed)
		this.control = vec3(2. * mid.x - 0.5 * (finish.x + start.x),
						2. * mid.y - 0.5 * (finish.y + start.y),
						2. * mid.z - 0.5 * (finish.z + start.z))

	/* To not repeat the same instructions form one constructor to another.
	I'd feel like Wurst having constructor call-chain (like in Java or C#), but no :( */
	protected function constructor(unit owner, string model, vec3 start, vec3 finish, real speed)
		this.owner = owner
		this.model = addEffect(model, start)
		this.start = start
		this.control = start.moveTowards(finish, start.distanceTo(finish)*0.5)
		this.finish = finish
		this.pos = start
		this.prevPos = start
		this.speed = speed
		distance = start.distanceTo2d(finish)
		orientation = vec3(0, 0, 1).toQuat(start.angleTo2d(finish))
		direction = orientation.getX()
		this.model.setOrientation(orientation)
		remain = distance
		if size == 1
			TIMER.startPeriodic(DELAY) ->
				for p in Projectile
					if not p.isPaused()
						p.update(DELAY)
				if Projectile.size == 0
					TIMER.pause()

	protected function update(real delay)
		if remain <= 0. or speed <= 0.
			return
		remain = remain > delay * speed ? remain-delay * speed : 0.
		if steering and remain > 0.
			updateSteering()
		updatePosition()
		if remain <= 0.
			remain = 0.
			impact()

	/** Called on impact. Override it. */
	protected function impact()
		model.destr()
		destroy this

	protected function updatePosition()
		prevPos = pos
		if remain > 0.
			pos = start.bezier3(control, finish, 1. - remain / distance)
		else
			remain = 0.
			pos = finish
		if belowTerrain
			model.setPos(pos)
		else
			let terrainZ = pos.getTerrainZ()
			if pos.z < terrainZ
				/* Cannot use setZ directly. The native function doesn't
				take into account previous changes. */
				model.setPosition(pos.x, pos.y, terrainZ)
			else
				model.setPos(pos)

	protected function updateSteering()
		let newDirection = start.derivBezier3(control, finish, 1. - remain/distance).norm()
		let axis = direction.cross(newDirection).norm()
		let a = direction.dot(newDirection).acos().asAngleRadians()
		if a.radians() > EPSILON
			if a.radians() > PI - EPSILON
				let y = orientation.getY()
				orientation = y.toQuat(angle(PI)).cross(orientation)
				direction = newDirection
			else
				let rot = axis.toQuat(a)
				orientation = rot.cross(orientation)
				direction = newDirection
			model.setOrientation(orientation)

	function enableSteering()
		steering = true
		updateSteering()

	function disableSteering()
		steering = false

	function getOwner() returns unit
		return owner

	function setOwner(unit newOwner)
		owner = newOwner

	function getOrientation() returns quat
		return orientation

	function setOrientation(quat orientation)
		this.orientation = orientation
		model.setOrientation(orientation)

	/** Returns the model's position in space. */
	function getPos() returns vec3
		return pos

	/** Does nothing if the projectile is in motion or unpaused. */
	function setPos(vec3 pos) returns bool
		if remain/distance < EPSILON or isPaused()
			this.pos = pos
			model.setPos(pos)
			return true
		return false

	/** Returns the model's previous position in space. */
	function getPrevPos() returns vec3
		return prevPos

	function getSpeed() returns real
		return speed

	function setSpeed(real speed)
		this.speed = speed

	function getTimeScale() returns real
		return timeScale

	/** Affects the model's animation, not movement. */
	function setTimeScale(real timeScale)
		this.timeScale = timeScale
		model.setTimeScale(timeScale)

	function getScale() returns real
		return scale

	function setScale(real scale)
		this.scale = scale
		model.setScale(scale)

	/** Sets vertex color. */
	function setColor(colorA clr)
		model.setColor(clr)
		this.clr = clr

	function getColor() returns colorA
		return clr

	/** Sets player color. */
	function setColorByPlayer(player p)
		model.setColorByPlayer(p)

	function getProgress() returns real
		return 1. - remain

	function pause()
		model.setTimeScale(0)
		paused = true

	function unpause()
		model.setTimeScale(timeScale)
		paused = false

	function isPaused() returns bool
		return paused

	/** The projectile's model can/can't be below terrain.
	True by default. */
	function belowTerrain(bool flag)
		this.belowTerrain = flag
