package Base64

import HashBuffer
import Bitwise
import StringUtils
import ByteBuffer
import Execute

// constants tuned to work on any optimization settings and with stacktraces
// this is very pessimistic, and could be much higher on higher opts, but we are conservative
constant ENCODES_PER_ROUND = 500
constant DECODES_PER_ROUND = 500

int loopCounter = 0
int loopActions = 0

// RFC 4648 compliant Base64 charmap.
constant CHARMAP = [
    "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
    "Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f",
    "g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v",
    "w","x","y","z","0","1","2","3","4","5","6","7","8","9","+","/"
]

// RFC 4648 compliant Base64 reverse charmap.
constant REVERSE_CHARMAP = [
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
    55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2,
    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
]

/**
    This is a class implementing a Base64 encoder compliant with RFC 4648.
    https://en.wikipedia.org/wiki/Base64

    Internally, it chunks data into strings of `maxChunkLength`. All produced
    strings will be of this length or less.

    To write data, use these provided methods:
        `Base64Encoder.pushByte()`
        `Base64Encoder.pushShort()`
        `Base64Encoder.pushInt()`

    After you are done writing, call:
        `Base64Encoder.encode()`
    This will run the encoding process of producing Base64-encoded strings.

    To extract these strings, use these provided methods:
        `Base64Encoder.hasChunk()`
        `Base64Encoder.popChunk()`

    For usage examples, look at tests in `Base64Tests.wurst`.
**/
public class Base64Encoder
    private var byteBuffer = new ByteBuffer
    private var stringBuffer = new HashBuffer
    private var stringCount = 0
    private var currentChunk = ""

    private int maxChunkLength

    construct(int maxChunkLength)
        this.maxChunkLength = maxChunkLength

    ondestroy
        destroy stringBuffer
        destroy byteBuffer

    private function flushChunk()
        stringBuffer.writeString(currentChunk)
        stringCount++
        currentChunk = ""

    private function append(string character)
        if currentChunk.length() >= maxChunkLength
            flushChunk()
        currentChunk += character

    private function encodeSingle(int byte, int count)
        var remaining = byte

        for i = 0 to count
            let c = remaining.and32(compiletime("11111100 00000000 00000000".fromBitString())).shiftr(18)
            append(CHARMAP[c])
            remaining = remaining.shiftl(6)

    private function encode3()
        let b1 = byteBuffer.readByte()
        let b2 = byteBuffer.readByte()
        let b3 = byteBuffer.readByte()
        let data = b1.shiftl(16) + b2.shiftl(8) + b3
        encodeSingle(data, 3)

    private function encode2()
        let b1 = byteBuffer.readByte()
        let b2 = byteBuffer.readByte()
        let data = b1.shiftl(16) + b2.shiftl(8)
        encodeSingle(data, 2)
        append("=")

    private function encode1()
        let b1 = byteBuffer.readByte()
        var data = b1.shiftl(16)
        encodeSingle(data, 1)
        append("=")
        append("=")

    /**
        Runs the encoding process of converting the provided data into Base64-encoded strings.
    **/
    function encode()
        execute() ->
            byteBuffer.toReadMode()

            let byteCount = byteBuffer.getByteCount()

            let noPaddingWrites = (byteBuffer.getByteCount() div 3) - 1
            let padding = byteCount mod 3

            loopActions = noPaddingWrites
            loopCounter = 0
            
            executeWhile(ENCODES_PER_ROUND, () -> loopCounter <= loopActions) ->
                encode3()
                loopCounter++

            if padding == 2
                encode2()

            if padding == 1
                encode1()

            if currentChunk.length() > 0
                flushChunk()

    /** Pushes an unsigned byte to be serialized into Base64. **/
    function pushByte(int byte)
        byteBuffer.writeByte(byte)

    /** Pushes an unsigned short to be serialized into Base64. **/
    function pushShort(int short)
        byteBuffer.writeShort(short)

    /** Pushes a signed int to be serialized into Base64. **/
    function pushInt(int num)
        byteBuffer.writeInt(num)

    /** Checks if there are any unextracted chunks. **/
    function hasChunk() returns boolean
        return stringCount > 0

    /** Extracts a Base64-encoded string chunk. **/
    function popChunk() returns string
        stringCount--
        let val = stringBuffer.readString()
        return val

function int.removeLastOctet() returns int
    return (this - (this div 0x1000000) * 0x1000000)

/**
    This is a class implementing a Base64 decoder almost compliant with RFC 4648.
    The only difference is that it will discard any unrecognized characters.
    https://en.wikipedia.org/wiki/Base64

    It takes chunks of Base64-encoded data with `Base64Decoder.pushChunk()`

    After you have populated the decoder with Base64 data, call `Base64Decoder.decode()`,
    this will process the input and put the decoder into read-mode.

    After this, you can extract your data using:
        `Base64Decoder.popByte()`
        `Base64Decoder.popShort()`
        `Base64Decoder.popInt()`
**/
public class Base64Decoder
    private var stringBuffer = new HashBuffer
    private var byteBuffer = new ByteBuffer
    private var charCount = 0
    private var currentChunk = ""
    private var currentChunkIndex = 0

    ondestroy
        destroy stringBuffer
        destroy byteBuffer

    private function loadNextChunk()
        currentChunk = stringBuffer.readString()
        currentChunkIndex = 0

    private function nextChar() returns int
        if currentChunkIndex >= currentChunk.length()
            loadNextChunk()
        let c = currentChunk.charAt(currentChunkIndex).toChar().toInt()
        currentChunkIndex++
        return c

    private function next3Bytes()
        var nextCharacter = nextChar()
        var data = 0
        var charAmount = 0

        if REVERSE_CHARMAP[nextCharacter] != -1
            data = REVERSE_CHARMAP[nextCharacter].shiftl(18)

        nextCharacter = nextChar()
        if REVERSE_CHARMAP[nextCharacter] != -1
            data = data + REVERSE_CHARMAP[nextCharacter].shiftl(12)
            charAmount++

        nextCharacter = nextChar()
        if REVERSE_CHARMAP[nextCharacter] != -1
            data = data + REVERSE_CHARMAP[nextCharacter].shiftl(6)
            charAmount++

        nextCharacter = nextChar()
        if REVERSE_CHARMAP[nextCharacter] != -1
            data = data + REVERSE_CHARMAP[nextCharacter]
            charAmount++
        
        while charAmount > 0
            byteBuffer.writeByte(data.toUnsigned().removeLastOctet().shiftr(16))
            data = data.shiftl(8)
            charAmount--

    /** Runs the decode process on provided input. **/
    function decode()
        let count = (charCount div 4) - 1

        loopCounter = 0
        loopActions = count

        executeWhile(DECODES_PER_ROUND, () -> loopCounter <= loopActions) ->
            next3Bytes()
            loopCounter++
        byteBuffer.toReadMode()

    /** Pushes a string of Base64-encoded data into the decoder to be decoded. **/
    function pushChunk(string chunk)
        charCount += chunk.length()
        stringBuffer.writeString(chunk)

    /** Returns the next 1 byte from the decoder as an unsigned byte. **/
    function popByte() returns int
        return byteBuffer.readByte()

    /** Returns the next 2 bytes from the decoder as an unsigned short. **/
    function popShort() returns int
        return byteBuffer.readShort()

    /** Returns the next 4 bytes from the decoder as a signed int. **/
    function popInt() returns int
        return byteBuffer.readInt()

    /** Returns the total amount of bytes in this decoder after the decoding process. **/
    function getByteCount() returns int
        return byteBuffer.getByteCount()
   