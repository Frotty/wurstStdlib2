package GroupUtils
import NoWurst
import Group
import ErrorHandling
import HashMap
import Execute
import Maths
import Annotations
import Unit
import MapBounds
import Boolexpr
import Player

/*
	Groups are a necessary evil that exists in warcraft 3, and sometimes their use
	cannot be easily replicated or avoided, especially with nested enums.

	However, for most purposes, if you want to keep a list of units and iterate over them
	often, you should use LinkedList<unit> instead of the group, since LinkedList<unit>
	provides more predictable and consistent functionalities that can be extended more easily.
*/

/** The max number of recyclable groups. Even if this number is reached,
	the system will create new groups on following requests, but they won't be recyclable.
	The maximum number for this setting is JASS_MAX_ARRAY_SIZE - 1. */
@configurable constant GROUP_NUMBER_LIMIT = 1024

/** The number of groups created when more are needed */
@configurable constant NEED_CREATE_GROUPS = 64

/** The number of groups created at start */
@configurable constant START_CREATE_GROUPS = 64

let used = new HashMap<group, bool>
group array stack
var numStack = 0
var numTotal = 0

/* API */

/** Returns a reusable group from the GroupUtils stack is possible.
	Creates new groups if none are found on the reusable stack.
	If that is not possible, returns a non-recyclable group and displays a warning. */
public function getGroup() returns group
	group retVal
	if numStack > 0
		retVal = pop()
	else if numStack <= 0 and numTotal < GROUP_NUMBER_LIMIT
		createGroups(NEED_CREATE_GROUPS)
		retVal = pop()
	else
		retVal = CreateGroup()
	return retVal

/** Recycles a group if it is created through GroupUtils, otherwise just destroys it.
	Doesn't affect ENUM_GROUP. */
public function group.release()
	if this == ENUM_GROUP
		Log.warn("Attemping to release ENUM_GROUP!")
	else
		if this.isRecyclable()
			if this.isUsed()
				this.recycle()
			else
				Log.warn("Attemping to release an already released group!")
		else
			this.clear()
			this.destr()

/* Recyclable iterator */

group iterGroup

public function group.recyclableIterator() returns group
	iterGroup = getGroup()
	ForGroup(this, () -> iterGroup.addUnit(GetEnumUnit()))
	return iterGroup

/* Group instantiation */

var shownMaxError = false

function createGroups(int number)
	let maxCreatePerCycle = 256
	let actualLimit = max(JASS_MAX_ARRAY_SIZE - 1, GROUP_NUMBER_LIMIT)
	let numTarget = numTotal + number
	let overflow  = max(0, numTarget - actualLimit)
	var toCreate  = max(0, numTarget - overflow)

	while toCreate > 0
		let createNow = min(toCreate, maxCreatePerCycle)
		toCreate -= createNow

		execute() ->
			numTotal += createNow
			for i = 1 to createNow
				push(CreateGroup())

	if numTotal >= GROUP_NUMBER_LIMIT and not shownMaxError
		Log.warn("Maximum number of GroupUtils groups (" + GROUP_NUMBER_LIMIT.toString() + ") created. "
			+ "All newly created groups will be non-recyclable.")
		shownMaxError = true

/** used to get units in rect with filter ! caution group needs to be released using group.release() after usage !*/
public function rect.getUnitsInRect(boolexpr filter) returns group
	let g = getGroup()
	GroupEnumUnitsInRect(g, this, filter)
	filter.destr()
	return g

/** used to get units in rect ! caution group needs to be released using group.release() after usage !*/
public function rect.getUnitsInRect() returns group
	return this.getUnitsInRect(null)
	
/** used to get units in rect without these from a given player ids ! caution group needs to be released using group.release() after usage !*/
public function rect.getUnitsInRectExcept(vararg int pIds) returns group
	let units = this.getUnitsInRect()
	for u in units
		for pId in pIds
			if u.getOwner().getId() == pId
				units.removeUnit(u)
	return units

/** used to get units in rect but only these from a specific player id ! caution group needs to be released using group.release() after usage !*/
public function rect.getUnitsInRectOnly(vararg int pIds) returns group
	let units = this.getUnitsInRect()
	for u in units
		for pId in pIds
			if u.getOwner().getId() != pId
				units.removeUnit(u)
	return units

/** used to get units in range of the point ! caution group needs to be released using group.release() after usage !*/
public function vec2.getUnitsInRange(real range) returns group 
	let g = getGroup()
	GroupEnumUnitsInRange(g, this.x, this.y, range, null)
	return g

/** used to get units in range of the loc, removing caster from the group ! caution group needs to be released using group.release() after usage !*/
public function vec2.getUnitsInRange(real range, unit caster) returns group 
	let g = this.getUnitsInRange(range)
	if caster != null
		g.removeUnit(caster)
	return g

/** used to get units in range of the loc between min and max range ! caution group needs to be released using group.release() after usage !*/
public function vec2.getUnitsInRangeEx(real minRange, real maxRange) returns group 
	let g = this.getUnitsInRange(maxRange)
	for u in g
		if u.getPos().distanceTo(this) < minRange
			g.removeUnit(u)
	return g

/** gets units in direction of a unit with a specific range and width ! caution group needs to be released using group.release() after usage !*/
public function unit.getUnitsInDirection(real range, real width, real facingAngle, bool isCone, boolexpr filter) returns group
	let pos  = this.getPos()
	let a	= facingAngle
	let p	= vec2(pos.x+range*Cos(a),  pos.y+range*Sin(a))
	let line = pos.getLineFormular(p)
	
	vec2 rP1
	vec2 rP2
	vec2 rP3
	vec2 rP4

	if isCone
		rP1 = pos
		rP2 = pos
		rP3 = p.getOrthognalSidePoint(line,	width/2) 
		rP4 = p.getOrthognalSidePoint(line,   -width/2)
	else
		rP1 = pos.getOrthognalSidePoint(line, -width/2) 
		rP2 = pos.getOrthognalSidePoint(line,  width/2) 
		rP3 = p.getOrthognalSidePoint(line,	width/2) 
		rP4 = p.getOrthognalSidePoint(line,   -width/2)

	let fpt = fourPointTuple(rP1, rP2, rP3, rP4)
	let r = Rect(fpt.getMinX(), fpt.getMinY(), fpt.getMaxX(), fpt.getMaxY())

	let g = r.getUnitsInRect(filter)
	for u in g
		if not fpt.isPointInside(u.getPos()) or u == this
			g.removeUnit(u)
	return g

@compiletime function initialize()
	createGroups(START_CREATE_GROUPS)

init
	initialize()

/** Returns whether this group was created through GroupUtils. */
function group.isRecyclable() returns bool
	return used.has(this)

/** Returns whether this group is currently being used */
function group.isUsed() returns bool
	return used.get(this)

/* Stack operations */

function push(group g)
	stack[numStack] = g
	used.put(stack[numStack], false)
	numStack++

bool shownDestrWarning = false

function pop() returns group
	numStack--
	var retVal = stack[numStack]

	if stack[numStack] != null
		used.put(stack[numStack], true)
	else
		if not shownDestrWarning
			Log.warn("Groups on the GroupUtils stack shouldn't be destroyed! Use .release() instead.")
			shownDestrWarning = true
		retVal = getGroup()
	return retVal

function group.recycle()
	this.clear()
	push(this)
