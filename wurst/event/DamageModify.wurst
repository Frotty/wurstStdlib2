/**
	DamageModify

	Never use both this and DamageType package.

	An important note:
	for damageListeners .amount is set to actual difference in target's life
	so damage won't be more than target's life if it has killed target (or it was saved)
	(a unit has 10 hp, it takes 100 damage, for damageModifiers it's 100 damage
	but for damageListeners it's 10 damage / 10 - .405 damage if .doSaveTarget == true)

	Examples:
	
	// Leech ability
	constant int LEECH_ID = compiletime(ABIL_ID_GEN.next())
	constant int LEECH_DAMAGE = compiletime(GetRandomInt(100, 200)) // just for lulz

	// Leech implementation #1
	function onLeechEffect1()
		let d = GetTriggerUnit().returnDamage(GetSpellTargetUnit(), LEECH_DAMAGE, true, 0)

		d.source.addHP(d.amount)
		d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		d.releaseInstance()

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect1)

	// Leech implementation #2
	function onLeechEffect2()
		GetTriggerUnit().damage(GetSpellTargetUnit(), LEECH_DAMAGE, LEECH_ID)

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
		addDamageListener() d ->
			if d.id == LEECH_ID	
				d.source.addHP(d.amount) // Leech effect implementation #2
				d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Simple damage resistance buff
	constant BUFF_DURATION = 5.0

	function onBuffEffect()
		let target = GetSpellTargetUnit()
		let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
		ForDamageCallback cb = () d ->
			if target == d.target
				d.amount -= d.initial * .5
		addDamageModifier(cb)
		doAfter(BUFF_DURATION) ->
			removeDamageModifier(cb)
			effect.destr()

*/
package DamageModify
import AbilityObjEditing
import DamageDetection
import OnUnitEnterLeave
import ObjectIdGenerator
import LinkedList
import ClosureTimers

/** If Damage instance wasn't created
	by one of DamageModify package's functions (or `new Damage(...)`),
	then Damage.id would be set to this value. */
@configurable public constant DAMAGE_ID_NONTRIGGERED = -1

/** Essentially used for callback closures taking on the form Damage -> null */
public interface ForDamageCallback
	function run(Damage d)

let damageModifiers = new LinkedList<ForDamageCallback>

/** These callbacks adjust damage before it happens.

	Is called once by default, but for manually created
	damage it is possible to call zero or multiple times. */
public function addDamageModifier(ForDamageCallback cb)
	damageModifiers.add(cb)

public function removeDamageModifier(ForDamageCallback cb)
	damageModifiers.remove(cb)

let damageListeners = new LinkedList<ForDamageCallback>

/** These callbacks are called right before the damage is dealt.

	Is called strictly once per damage instance. */
public function addDamageListener(ForDamageCallback cb)
	damageListeners.add(cb)

public function removeDamageListener(ForDamageCallback cb)
	damageListeners.remove(cb)

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions.
	Damage instance is saved and returned after being dealt. 

	Is a helper for `new Damage(this, target, amount, spell, 0)..saveInstance()..modify()..deal()` */
public function unit.returnDamage(unit target, real amount, bool spell, int id) returns Damage
	return new Damage(this, target, amount, spell, id)..saveInstance()..modify()..deal()

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions. 

	Is a helper for `new Damage(this, target, amount, spell, id)..modify()..deal()` */
public function unit.damage(unit target, real amount, bool spell, int id)
	new Damage(this, target, amount, spell, id)..modify()..deal()

/** Deals triggered damage from unit to target.

	Is a helper for `new Damage(this, target, amount, spell, 0)..modify()..deal()` */
public function unit.damage(unit target, real amount, bool spell)
	new Damage(this, target, amount, spell, 0)..modify()..deal()
/** Deals triggered spell damage from unit to target.

	Is a helper for `new Damage(this, target, amount, true, 0)..modify()..deal()` */
public function unit.damage(unit target, real amount)
	new Damage(this, target, amount, true, 0)..modify()..deal()

// ConvertAttackType(7) is a hidden attack type with some unique properties.
// For more information see "goo.gl/9k8tn".
// Note that the values in the table at this link are outdated, but the principle still applies.
constant ATTACK_TYPE_UNIVERSAL = ConvertAttackType(7)
constant DAMAGE_TYPE_CHECK_ID = compiletime(ABIL_ID_GEN.next())
constant CHEAT_DEATH_ID = compiletime(ABIL_ID_GEN.next())

public class Damage
	/** Should store source ability of the Damage.

		It is set in `new Damage` by user's value.
		Helper functions do set this to 0.

		If Damage instance wasn't created
		by one of DamageModify package's functions (or `new Damage(...)`),
		then this would be set to DAMAGE_ID_NONTRIGGERED. */
	integer id
	/** Who is dealing the damage. */
	unit source
	/** Who is recieving the damage. */
	unit target
	/** If the Damage is of ATTACK_TYPE_NORMAL */
	bool spell
	/** What amount of damage was originally convieved. */
	real initial
	/** What amount of damage was/will be dealt to `target`.
	
		"amount of damage" == "amount of HP to remove" */
	real amount

	protected bool doSaveTarget = false
	/** Call this if you want to save the target.
		This means that target won't die from the damage,
		no matter how big `amount` would be. */
	function saveTarget()
		doSaveTarget = true

	/** Damage instances are automatically destroyed.
		Use this to protect them if you need an instance anyhow.
		
		You need then to use `releaseInstance()`
		in order to destroy the instance.

		This means that the instance will be destroyed
		when the last `releaseInstance()` is called on it. */
	function saveInstance()
		wantSave += 1

	/** Releases Damage instance so it can be destroyed.
		It is destroyed immediately if nobody else had saved it. */
	function releaseInstance()
		wantSave -= 1
		if fired and wantSave <= 0
			destroy this

	/** The counter inside saveInstance() and releaseInstance(). */
	protected int wantSave = 0
	ondestroy
		if wantSave > 0
			Log.error("Damage instance was unsafely destroyed! Use .releaseInstance() instead!")

	/** It is set to true if the damage, when it was dealt, killed the target. */
	protected bool killingBlow = false
	/** If the damage was dealt. */
	private bool fired = false

	/** applies all modifiers to the damage instance once */
	function modify()
		for i in damageModifiers
			i.run(this)

	protected function anounce()
		for i in damageListeners
			i.run(this)
		fired = true

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return killingBlow or (not fired and target.getHP() - .405 < amount)
		
	/** Multiplies initial damage with given magnitude
		(increases `amount` by `initial` * magnitude) */
	function addMultiplier(real magnitude)
		amount += initial * (magnitude - 1)

	/** Increases `amount` with given amount */
	function addAmount(real amount)
		this.amount += amount
		
	construct(unit source, unit target, real amount, bool isSpell, int id)
		this.source = source
		this.target = target
		this.initial = amount
		this.amount = amount
		spell = isSpell
		this.id = id

	/** applies user-created Damage instance. */
	function deal()
		if not fired
			anounce()
			if target.isAlive()
				let life = target.getHP()
				killingBlow = life - .405 < amount and not doSaveTarget			
				amount = dealCodeDamage(source, target, amount, killingBlow)
			if this.wantSave <= 0
				destroy this
		else
			Log.warn("Damage.deal() called on already fired damage!")

/** Deal an exact amount of damage to `target`, crediting kill experience and
	gold bounty to `attacker` and not triggering any of DamageDetection listeners.
	KillingBlow parameter decides whether to kill the target.
	Isn't supposed to use outside of the system. */
function dealCodeDamage(unit attacker, unit target, real damage, bool killingBlow) returns real
	real d = 0.
	let hp = target.getHP()
	disableDamageDetect()
	if not killingBlow
		if damage != 0
			d = min(hp - .405, damage)
			target.setHP(hp-d)
			attacker.damageTarget(target, 0., ATTACK_TYPE_UNIVERSAL)
			attacker.damageTarget(target, 0., ATTACK_TYPE_MAGIC)
	else
		// Deal damage using two separate components. The ATTACK_TYPE_UNIVERSAL
		// case will deal damage to units of all armor types, even if that armor
		// would otherwise block all damage. The ATTACK_TYPE_MAGIC case affect
		// ethereal units, whereas other attack types do not.
		d = hp
		target.setHP(.405)
		attacker.damageTarget(target, 1000000., ATTACK_TYPE_UNIVERSAL)
		attacker.damageTarget(target, 1000000., ATTACK_TYPE_MAGIC)
	enableDamageDetect()
	return d

function handler() returns bool
	let damage = GetEventDamage()
	if damage == 0
		return false

	let d = new Damage(GetEventDamageSource(), GetTriggerUnit(), (damage < 0 ? -damage : damage), damage < 0, DAMAGE_ID_NONTRIGGERED)

	d.modify()
	d.anounce()

	let life = d.target.getHP()
	d.killingBlow = life - .405 < d.amount
	if d.killingBlow
		if d.doSaveTarget
			d.amount = life - .406
			d.killingBlow = false
		else
			// So the unit should die no matter what. The following line should secure it.
			d.amount = dealCodeDamage(d.source, d.target, life, true) // DIE, INSECT!!!
			return false
		
	real rLife
	bool doTimer
	real afterDamage = 0
	if d.spell
		// After all: life += -d.amount - d.initial // + d.initial from event
		rLife = life - d.initial - d.amount
		doTimer = rLife < .405
		if doTimer
			afterDamage = d.initial + d.amount
	else
		// After all: life += -d.amount + d.initial // - d.initial from event 
		rLife = life + d.initial - d.amount
		doTimer = rLife > d.target.getMaxHP()
		if doTimer
			d.target.addAbility(CHEAT_DEATH_ID)
			d.target.setHP(rLife)
			
	if doTimer
		nullTimer() ->
			let hp = d.target.getHP()
			d.target.removeAbility(CHEAT_DEATH_ID)
			d.target.setHP(hp)
			dealCodeDamage(d.source, d.target, afterDamage, false)
		
			if d.wantSave == 0
				destroy d
	else
		d.target.setHP(rLife)

	return false

init
	onEnter() ->
		getEnterLeaveUnit()..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	addOnDamageFunc(Condition(function handler))

@compiletime function generateAbility()
	new AbilityDefinitionRunedBracers(DAMAGE_TYPE_CHECK_ID)
		..setName("Runed Bracer Dummy")
		..setEditorSuffix("(DamageType)")
		..setItemAbility(false)
		..setDamageReduction(1, 2.)
	new AbilityDefinitionAIhe(CHEAT_DEATH_ID)
		..setName("Cheat Death Dummy")
		..setEditorSuffix("(Damage)")
		..setItemAbility(false)
		..setHitPointsGained(1, 1000000)
