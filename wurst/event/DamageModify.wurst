package DamageModify
import DamageDetection
import LinkedList
import HashSet
import DamageType
/*	
	// Overview
	The main objective of this system is to have same damage event-related object at all stages of damage event.
	It implements `Damage` class which contains all arguments of `UnitDamageTarget` native plus one integer for additional attachments.
	This allows to easily access and modify event data.

	// Basic usage

	There's Modifiers and Listeners that can be used to process damage events.
	Modifiers are run before Listeners.

	So here's some examples to demonstrate basic functional of this system.
	Note: all getters are inlined.

	Damage amplification debuff.
	addDamageModifier() damage ->
		if damage.getTarget().hasAbility(DEBUFF_ID)
			damage.addMultiplier(1.25)
	
	Passive block ability.
	addDamageModifier() damage ->
		if damage.getTarget().hasAbility(BLOCK_ID)
			damage.addAmount(-12) // Won't modify below 0.

	Damage displaying snippet.
	addDamageListener() damage ->
		if IsUnitVisible(damage.getTarget(), localPlayer)
			createCriticalStrikeTextTag(damage.getTarget(), damage.getActual())
			..setColor(damage.getSource().getColor().toColor().withAlpha(255))

	Spell that is modified twice.
	registerSpellEffectEvent(ARCANE_BLAST_ID) ->
		new Damage(GetTriggerUnit(), GetSpellTargetUnit(), BLAST_DAMAGE, ATTACK_TYPE_NORMAL, 0, false)..setModifyCount(2)..deal()

	Spell with pure damage.
	registerSpellEffectEvent(FINGER_ID) ->
		new Damage(GetTriggerUnit(), GetSpellTargetUnit(), FINGER_DAMAGE, ATTACK_TYPE_NORMAL, 0, false)..setModifyCount(0)..deal()

	Blast would do BLAST_DAMAGE * 1.25^2 - 24 damage to debuffed unit with block,
	while Finger of Death would do FINGER_DAMAGE damage to the same unit.

	Considering it had full health.
	And still both of these damages would be displayed as a text tags.

	// Advanced usage

		// Instance lifetime manipulation
	By default, any Damage instance is destroyed throughout the damage event.
	But should user set the last argument in Damage constructor to `true`,
	the Damage won't be destroyed and thus it would be possible to easily retrieve
	damage outcome: whether exactly this has killed the target, how much HP did
	it loss, how much the damage was modified.

	This broadens possibilities in designing of unique abilities while creating
	no overhead at all. Just don't forget to free the instance in the end.

	Here's an example of a leeching ability that can't leech more than targets HP.
	registerSpellEffectEvent(LEECH_ID) ->
		let d = new Damage(GetTriggerUnit(), GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, 0, true)

		d.getSource().addHP(d.getActual()) // Heal is capped at target's hp
		d.getSource().addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		destroy d

		// Damage recursion
	It is strongly recommended to use system's functions to 

		// Data carrying
	There's one additional integer field for the damage.

	// Specification

	Damage instance can be created before damage invokation, thus it can be modified anyhow before the event.
	It is guaranteed to be passed to modifiers and listeners during the event invoked through `.deal()` method.
	And then the instance is still accessable (in case it was saved), allowing user to easily retrieve event data.

	System is guaranteed to work as in documentation only if there's no listeners in DamageDetection after this package's one.
	The system does not handle 0 damage events.
	
	Has several cases of possibly unexpected behavior:
	- Actual amount can not go below zero or above target's HP.
	- Event Damage is set to .actualAmount, not .amount.
	- Damage instance can not be modified from inside listeners.

	There will be output to debug log stream if anything would go wrong,
	for example if system will fail to pass/catch Damage instance in between
	damage instance creation and it's handling (.deal() and .handle()).
	
	Examples:
	
	// Leech implementation #1

	// Leech implementation #2
	function onLeechEffect2()
		GetTriggerUnit().damageTarget(GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, LEECH_ID)

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
		addDamageListener() d ->
			if d.data == LEECH_ID
				d.source.addHP(d.getActual())
				d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Simple damage resistance buff
	import UniqueDamageListening

	function onBuffEffect()
		let target = GetSpellTargetUnit()
		let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
		let cb = addTargetDamageModifier() d ->
			d.amount -= d.initialAmount * .5
		doAfter(BUFF_DURATION) ->
			removeTargetDamageModifier(cb)
			effect.destr()

	init
		registerSpellEffectEvent(BUFF_ID, function onLeechEffect2)
*/

// Configuration

/** If Damage instance wasn't created by one of DamageModify package's functions
	(or `new Damage(...)`), then Damage.data would be set to this value */
@configurable public constant DAMAGE_NONTRIGGERED_DATA = -1

/** Maximum amount of damage events that can happen in a single event */
@configurable public constant RECURSION_TRESHOLD = 32

/** Describes default way to create Damage instance if damage event doesn't
	correspond to any Damage instance. */
@configurable function getDamageFromEvent() returns Damage
	return GetEventDamage() == 0 ? null : new Damage(GetEventDamageSource(), GetTriggerUnit(), GetEventDamage(), false, false, getDamageType() == DamageType.SPELL ? ATTACK_TYPE_NORMAL : ATTACK_TYPE_CHAOS, null, null, DAMAGE_NONTRIGGERED_DATA, false)

/** Should return whether retrieved Damage data matches event data. Is used to
	check triggered damage  */
@configurable function Damage.compareWithEventData() returns bool
	return this.getSource() == GetEventDamageSource() or this.getTarget() == GetTriggerUnit()

// Wrappers for unit.damageTarget with data attachment

/** Deals triggered damage from unit to target. Additional data can be specified.

	Is a helper for `new Damage(*args*, false)..deal()`, where last
	arg specifies whether the instance should not be destroyed during the event.
	If you need instance after it has been dealt, create it manually. */
public function unit.damageTarget(unit target, real amount, bool attack, bool ranged, attacktype attackType, damagetype damageType, weapontype weaponType, int data)
	new Damage(this, target, amount, attack, ranged, attackType, damageType, weaponType, data, false)..deal()

public function unit.damageTarget(unit target, real amount, attacktype attackType, int data)
	this.damageTarget(target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

public function unit.damageTarget(unit target, real amount, int data)
	this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

Damage previousDamage = null
Damage dealingInstance = null

let queue = new LinkedList<Damage>
int recursionAmount = 0
bool needTimer = false
bool dequeueRunning = false
timer nullTimer = CreateTimer()

/** Returns the damage instance that was created on last Damage event.
	For both listeners and modifiers it is previous to callback argument.

	Allows to retrieve the instance right after unit.damageTarget() call,
	but it is not guaranteed. */
public function getPreviousDamage() returns Damage
	return previousDamage

// Callbacks with direct Damage instance acquirement

/** These callbacks are used to modify the damage.

	They can be called zero or more times, so that their call is not guaranteed
	for every instance, still the usual case is one time per instance. */
public interface DamageModifier
	function modify(Damage d)

/** These callbacks are used to listen to the damage.

	They are called strictly once per every damage instance, guaranteed,
	but they are disabled to modify. */
public interface DamageListener
	function listen(Damage d)

let damageModifiers = new HashSet<DamageModifier>

let damageListeners = new HashSet<DamageListener>

public function addDamageModifier(DamageModifier cb) returns DamageModifier
	damageModifiers.add(cb)
	return cb

public function removeDamageModifier(DamageModifier cb)
	damageModifiers.remove(cb)

public function addDamageListener(DamageListener cb) returns DamageListener
	damageListeners.add(cb)
	return cb

public function removeDamageListener(DamageListener cb)
	damageListeners.remove(cb)

enum DamageState
	CREATED // Initial state after creation
	QUEUED // Damage.deal() is called
	FIRING // Damage.invoke() is called
	ACQUIRED // Damage is acquired by damage event handler
	MODIFYING // Damage.modify() is called
	LISTENING // Last processing stage; modifying is forbidden
	FIRED // Damage instance is completely processed by system

public function DamageState.toString() returns string
	switch this
		case CREATED
			return "created"
		case QUEUED
			return "queued"
		case FIRING
			return "firing"
		case ACQUIRED
			return "acquired"
		case MODIFYING
			return "modifying"
		case LISTENING
			return "listening"
		case FIRED
			return "fired"

	return "error"

public class Damage

	/** Custom field which can be pinned damage event */
	integer data

	private unit source
	private unit target
	private bool ranged
	private bool attack
	private attacktype attackType
	private damagetype damageType
	private weapontype weaponType

	/** What amount of damage was originally convieved */
	private real initialAmount
	/** What amount of damage was convieved after modification*/
	private real amount
	/** Final amount of damage event */
	protected real actualAmount = 0
	/** Amount of times that each DamageModifier is applied to this damage. */
	protected int modifyCount = 1

	protected bool doPreventDeath = false
	protected bool doDeflect = false
	
	/** Holds info about damage event state */
	protected DamageState state = DamageState.CREATED
	/** It is set to true if the damage, when it was dealt, killed the target */
	protected bool killedTarget = false

	protected bool isReturned = false

	function getSource() returns unit
		return source
	function getTarget() returns unit
		return target
	function getRanged() returns bool
		return ranged
	function getAttack() returns bool
		return attack
	function getAttackType() returns attacktype
		return attackType
	function getDamageType() returns damagetype
		return damageType
	function getWeaponType() returns weapontype
		return weaponType
	function getState() returns DamageState
		return state

	/** If the damage is modified by spell bracers ability. */
	function isSpell() returns bool
		return attackType == ATTACK_TYPE_NORMAL

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return (state == DamageState.FIRED and killedTarget) or (state != DamageState.FIRED and target.getHP() - .406 < amount)

	/** Returns true if the damage have killed target
		Is valid only for listeners and after the event. */
	function hasKilledTarget() returns bool
		if state == DamageState.FIRED or state == DamageState.LISTENING
			return killedTarget

		Log.error("Damage.hasKilledTarget() is used in the wrong damage state:" + state.toString())
		return false

	function getInitial() returns real
		return initialAmount
	
	/** Returns the actual damage that was withdrawn from the unit.
		Becomes valid only for listeners and after the event. */
	function getActual() returns real
		if state == DamageState.FIRED or state == DamageState.LISTENING
			return actualAmount
		Log.error("Damage.getActual() is used in the wrong damage state:" + state.toString())
		return getAmount()

	function getAmount() returns real
		return amount
	
	/** Returns amount of times that each DamageModifier is applied to this damage.
		
		Defaults to 1, but can be set to range [0, 32]. */
	function getModifyCount() returns int
		return modifyCount
	
	// Manual instance creation

	private function set(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data, bool isReturned)
		this.source = source
		this.target = target
		this.initialAmount = amount
		this.amount = amount
		this.ranged = ranged
		this.attack = attack
		this.attackType = attackType
		this.damageType = damageType
		this.weaponType = weaponType
		this.data = data
		this.isReturned = isReturned

	/** Allows manual creation of Damage instance, which is then dealt
		through .deal() call, guaranteed passing it to modifiers and listeners.

		You can attach anything to Damage instance with .data field.
		isReturned specifies whether the Damage should not be destroyed during the event. */
	construct(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data, bool isReturned)
		set(source, target, amount, ranged, attack, attackType, damageType, weaponType, data, isReturned)

	construct(unit source, unit target, real amount, attacktype attackType, int data, bool isReturned)
		set(source, target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data, isReturned)
	
	construct(unit source, unit target, real amount, int data, bool isReturned)
		set(source, target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data, isReturned)

	ondestroy
		if state != DamageState.CREATED or state != DamageState.FIRED
			Log.error("destroy Damage is used in the wrong damage state:" + state.toString())

	/** applies user-created Damage instance, instantly processing it through
		all damage events. After this function is called, the Damage will be
		in 'fired' state. */
	function deal()
		if state == DamageState.CREATED
			// What is described in hotdoc happens in .invoke()
			// While this is a wrapper to handle recursive damage properly
			if recursionAmount > RECURSION_TRESHOLD
				Log.warn("Damage.deal(): Recursion treshold has been hit.")
				return
			state = DamageState.QUEUED
			queue.push(this)
			if not dequeueRunning
				dequeueRunning = true
				if needTimer
					nullTimer.start(0, function dequeue)
				else
					dequeue()
		else
			Log.error("Damage.deal() is used in the wrong damage state:" + state.toString())			

	protected function invoke()
		state = DamageState.FIRING
		let temp = dealingInstance
		dealingInstance = this
		Log.trace("deal d" + (this castTo int).toString())
		UnitDamageTarget(source, target, amount, attack, ranged, attackType, damageType, weaponType)
		Log.trace("completed d" + (this castTo int).toString())
		dealingInstance = temp
		if state != DamageState.FIRED
			Log.error("Damage.deal() returned not fully processed damage! (state: " + state.toString() + ")")
			if not isReturned
				destroy this
			
	// Event modification

	/** Make actual amount leave target at at least 0.406 hp left */
	function preventDeath()
		doPreventDeath = true

	/** Nullifies actual amount no matter what. */
	function deflect()
		doDeflect = true

	/** Increases `amount` of the damage by `initialAmount * magnitude` */
	function addMultiplier(real magnitude)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			amount += initialAmount * (magnitude - 1)
		else
			Log.error("Damage.addMultiplier() is used in the wrong damage state:" + state.toString())			

	/** Increases `amount` of the damage with given amount */
	function addAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount += amount
		else
			Log.error("Damage.addAmount() is used in the wrong damage state:" + state.toString())			

	/** Sets `amount` of the damage to given amount */
	function setAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount = amount
		else
			Log.error("Damage.setAmount() is used in the wrong damage state:" + state.toString())

	/** Sets the amount of times that each DamageModifier is applied to this damage.
		Should be in range [0, 32]. */
	function setModifyCount(int val)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			if val >= 0 and val <= 32
				modifyCount = val
			else
				Log.error("Damage.setModifyCount() is used with wrong value: " + val.toString())
		else
			Log.error("Damage.setModifyCount() is used in the wrong damage state:" + state.toString())
				

// Handler of the event

function dequeue()
	while true
		let next = queue.dequeue()
		if next == null
			break
		next.invoke()
	dequeueRunning = false
	recursionAmount = 0
	needTimer = false

function retrieve() returns Damage
	var d = dealingInstance
	if not d.compareWithEventData()
		Log.warn("Damage.retrieve() has ignored a damage due to incorrect data!")
		d = null
	if d != null
		dealingInstance = null // let no one else retrieve the same instance
	return d

function handler() returns bool
	real damage_ratio = 1
	var damage = retrieve()
	if damage == null
		damage = getDamageFromEvent()

		if damage == null
			return false

		if recursionAmount == 0
			needTimer = true
		else
			Log.error("Non-triggered damage recursion detected.")
	else
		damage_ratio = GetEventDamage() / damage.getInitial()
	
	recursionAmount += 1
	damage.state = DamageState.ACQUIRED
	
	for i = 0 to damage.modifyCount
		damage.addMultiplier(damage_ratio)
		damage.state = DamageState.MODIFYING
		for modifier in damageModifiers
			modifier.modify(damage)
		damage.state = DamageState.ACQUIRED
	
	if damage.doDeflect
		damage.actualAmount = 0
	else
		let life = damage.getTarget().getHP()
		damage.killedTarget = life - .406 < damage.getAmount()
		if damage.killedTarget 
			if damage.doPreventDeath
				damage.killedTarget = false
				damage.actualAmount = life - .406
			else
				damage.actualAmount = life
		else
			damage.actualAmount = damage.getAmount()

		if damage.actualAmount < 0
			damage.actualAmount = 0
	BlzSetEventDamage(damage.actualAmount)

	damage.state = DamageState.LISTENING
	for listener in damageListeners
		listener.listen(damage)
	damage.state = DamageState.FIRED

	if previousDamage != null and not previousDamage.isReturned
		destroy previousDamage
	previousDamage = damage

	if not dequeueRunning
		recursionAmount = 0
	
	Log.trace("finish damage" + (damage castTo int).toString())
	return false

init
	addOnDamageFunc(Condition(function handler))
