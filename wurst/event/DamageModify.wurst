package DamageModify
import DamageDetection
import LinkedList
import DamageType
/*
	The main objective of this system is to have same damage event-related object at all stages of damage event.
	It implements `Damage` class which contains all arguments of `UnitDamageTarget` native plus one integer for additional attachments.
	Features custom instance lifetime.
	Callbacks have Damage instance as an argument.

	Damage instance can be created before damage invokation, thus it can be modified anyhow before the event.
	It is guaranteed to be passed to modifiers and listeners during the event invoked through `.deal()` method.
	And then the instance is still accessable (in case it was saved), allowing user to easily retrieve event data.

	System is guaranteed to work as in documentation only if there's no listeners in DamageDetection after this package's one.
	The system does not handle 0 damage events.
	
	Has several cases of possibly unexpected behavior:
	- Actual amount can not go below zero or above target's HP.
	- Event Damage is set to .actualAmount, not .amount.
	- Damage instance can not be modified from inside listeners.

	There will be output to debug log stream if anything would go wrong,
	for example if system will fail to pass/catch Damage instance in between
	damage instance creation and it's handling (.deal() and .handle()).
	
	Examples:
	
	// Leech implementation #1
	function onLeechEffect1()
		// Using wrapper from the package, event data is retrieved easily.
		let d = GetTriggerUnit().damageTarget(GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, 0)

		d.source.addHP(d.getActual()) // Heal is capped at target's hp
		d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		d.releaseInstance() // Don't forget to free the instance

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect1)

	// Leech implementation #2
	function onLeechEffect2()
		GetTriggerUnit().damageTarget(GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, LEECH_ID)

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
		addDamageListener() d ->
			if d.data == LEECH_ID
				d.source.addHP(d.getActual())
				d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Simple damage resistance buff
	import UniqueDamageListening

	function onBuffEffect()
		let target = GetSpellTargetUnit()
		let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
		let cb = addTargetDamageModifier() d ->
			d.amount -= d.initialAmount * .5
		doAfter(BUFF_DURATION) ->
			removeTargetDamageModifier(cb)
			effect.destr()

	init
		registerSpellEffectEvent(BUFF_ID, function onLeechEffect2)
*/

// Configuration

/** If Damage instance wasn't created by one of DamageModify package's functions
	(or `new Damage(...)`), then Damage.data would be set to this value */
@configurable public constant DAMAGE_NONTRIGGERED_DATA = -1

/** Describes default way to create Damage instance if damage event doesn't
	correspond to any Damage instance. */
@configurable function getDamageFromEvent() returns Damage
	return new Damage(GetEventDamageSource(), GetTriggerUnit(), GetEventDamage(), false, false, getDamageType() == DamageType.SPELL ? ATTACK_TYPE_NORMAL : ATTACK_TYPE_CHAOS, null, null, DAMAGE_NONTRIGGERED_DATA, false)

// Wrappers for unit.damageTarget with data attachment

/** Deals triggered damage from unit to target. Additional data can be specified.

	Is a helper for `new Damage(*args*, false)..modify()..deal()`, where last
	arg specifies whether the instance should not be destroyed during the event.
	If you need instance after it has been dealt, create it manually. */
public function unit.damageTarget(unit target, real amount, bool attack, bool ranged, attacktype attackType, damagetype damageType, weapontype weaponType, int data)
	new Damage(this, target, amount, attack, ranged, attackType, damageType, weaponType, data, false)..deal()

public function unit.damageTarget(unit target, real amount, attacktype attackType, int data)
	this.damageTarget(target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

public function unit.damageTarget(unit target, real amount, int data)
	this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

Damage previousDamage = null

/** Returns the damage instance that was created on last Damage event.
	For both listeners and modifiers it is previous to callback argument.

	Allows to retrieve the instance right after unit.damageTarget() call,
	but it is not guaranteed. */
public function getPreviousDamage() returns Damage
	return previousDamage


// Callbacks with direct Damage instance acquirement

/** These callbacks are used to modify the damage.

	They can be called zero or more times, so that their call is not guaranteed
	for every instance, still the usual case is one time per instance. */
public interface DamageModifier
	function modify(Damage d)

/** These callbacks are used to listen to the damage.

	They are called strictly once per every damage instance, guaranteed,
	but they are disabled to modify. */
public interface DamageListener
	function listen(Damage d)

let damageModifiers = new LinkedList<DamageModifier>

let damageListeners = new LinkedList<DamageListener>

public function addDamageModifier(DamageModifier cb) returns DamageModifier
	damageModifiers.add(cb)
	return cb

public function removeDamageModifier(DamageModifier cb)
	damageModifiers.remove(cb)

public function addDamageListener(DamageListener cb) returns DamageListener
	damageListeners.add(cb)
	return cb

public function removeDamageListener(DamageListener cb)
	damageListeners.remove(cb)

// The wrapper class

enum DamageState
	CREATED // Initial state after creation
	FIRING // Damage.deal() is called
	ACQUIRED // Damage is acquired by damage event handler
	MODIFYING // Damage.modify() is called
	LISTENING // Last processing stage; modifying is forbidden
	FIRED // Damage instance is completely processed by system

public function DamageState.toString() returns string
	switch this
		case CREATED
			return "created"
		case FIRING
			return "firing"
		case ACQUIRED
			return "acquired"
		case MODIFYING
			return "modifying"
		case LISTENING
			return "listening"
		case FIRED
			return "fired"

	return "error"

Damage dealingInstance

public class Damage

	// Event info

	/** Custom field which can be pinned damage event */
	integer data

	private unit source
	private unit target
	private bool ranged
	private bool attack
	private attacktype attackType
	private damagetype damageType
	private weapontype weaponType

	/** What amount of damage was originally convieved */
	private real initialAmount
	/** What amount of damage was convieved after modification*/
	private real amount
	/** Final amount of damage event */
	protected real actualAmount = 0
	/** Amount of times that each DamageModifier is applied to this damage. */
	protected int modifyCount = 1

	protected bool doPreventDeath = false
	protected bool doDeflect = false
	
	/** Holds info about damage event state */
	protected DamageState state = DamageState.CREATED
	/** It is set to true if the damage, when it was dealt, killed the target */
	protected bool killedTarget = false

	protected bool isReturned = false

	function getSource() returns unit
		return source
	function getTarget() returns unit
		return target
	function getRanged() returns bool
		return ranged
	function getAttack() returns bool
		return attack
	function getAttackType() returns attacktype
		return attackType
	function getDamageType() returns damagetype
		return damageType
	function getWeaponType() returns weapontype
		return weaponType
	function getState() returns DamageState
		return state

	/** If the damage is modified by spell bracers ability. */
	function isSpell() returns bool
		return attackType == ATTACK_TYPE_NORMAL

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return (state == DamageState.FIRED and killedTarget) or (state != DamageState.FIRED and target.getHP() - .406 < amount)

	/** Returns true if the damage have killed target
		Is valid only for listeners and after the event. */
	function hasKilledTarget() returns bool
		if state == DamageState.FIRED or state == DamageState.LISTENING
			return killedTarget
		else
			Log.debug("Damage.hasKilledTarget() is used on not dealt instance!")
			return false

	function getInitial() returns real
		return initialAmount
	/** Returns the actual damage that was withdrawn from the unit.
		Becomes valid only for listeners and after the event. */
	function getActual() returns real
		if state == DamageState.FIRED or state == DamageState.LISTENING
			return actualAmount
		Log.debug("Damage.getActual() is used on not dealt instance!")
		return getAmount()
	function getAmount() returns real
		return amount
	/** Returns amount of times that each DamageModifier is applied to this damage.
		
		Defaults to 1, but can be set to range [0, 32]. */
	function getModifyCount() returns int
		return modifyCount
	
	// Manual instance creation

	private function set(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data, bool isReturned)
		this.source = source
		this.target = target
		this.initialAmount = amount
		this.amount = amount
		this.ranged = ranged
		this.attack = attack
		this.attackType = attackType
		this.damageType = damageType
		this.weaponType = weaponType
		this.data = data
		this.isReturned = isReturned

	/** Allows manual creation of Damage instance, which is then dealt
		through .deal() call, guaranteed passing it to modifiers and listeners.

		You can attach anything to Damage instance with .data field.
		isReturned specifies whether the Damage should not be destroyed during the event. */
	construct(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data, bool isReturned)
		set(source, target, amount, ranged, attack, attackType, damageType, weaponType, data, isReturned)

	construct(unit source, unit target, real amount, attacktype attackType, int data, bool isReturned)
		set(source, target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data, isReturned)
	
	construct(unit source, unit target, real amount, int data, bool isReturned)
		set(source, target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data, isReturned)
			
	/** applies user-created Damage instance, instantly processing it through
		all damage events. After this function is called, the Damage will be
		in 'fired' state. */
	function deal()
		if state == DamageState.CREATED
			state = DamageState.FIRING
			let temp = dealingInstance
			dealingInstance = this
			Log.trace("deal d" + I2S(this castTo int))
			UnitDamageTarget(source, target, amount, attack, ranged, attackType, damageType, weaponType)
			Log.trace("completed d" + I2S(this castTo int))
			dealingInstance = temp
			if state != DamageState.FIRED
				Log.debug("Damage.deal() returned not fully processed damage! (state: " + state.toString() + ")")
				if not isReturned
					destroy this
		else
			Log.debug("Damage.deal() called on already dealt damage!")
			
	// Event modification

	/** Make actual amount leave target at at least 0.406 hp left */
	function preventDeath()
		doPreventDeath = true

	/** Nullifies actual amount no matter what. */
	function deflect()
		doDeflect = true

	/** Increases `amount` of the damage by `initialAmount * magnitude` */
	function addMultiplier(real magnitude)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			amount += initialAmount * (magnitude - 1)
		else
			Log.debug("Damage.addMultiplier() is used in the wrong damage state:" + state.toString())			

	/** Increases `amount` of the damage with given amount */
	function addAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount += amount
		else
			Log.debug("Damage.addAmount() is used in the wrong damage state:" + state.toString())			

	/** Sets `amount` of the damage to given amount */
	function setAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount = amount
		else
			Log.debug("Damage.setAmount() is used in the wrong damage state:" + state.toString())

	/** Sets the amount of times that each DamageModifier is applied to this damage.
		Should be in range [0, 32]. */
	function setModifyCount(int val)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			if val >= 0 and val <= 32
				modifyCount = val
			else
				Log.debug("Damage.setModifyCount() is used with wrong value: " + val.toString())
		else
			Log.debug("Damage.setModifyCount() is used in the wrong damage state:" + state.toString())
				

// Handler of the event

function retrieve() returns Damage
	var d = dealingInstance
	if d == null or d.getSource() != GetEventDamageSource() or d.getTarget() != GetTriggerUnit()
		if d != null
			Log.debug("Damage.handler() was ignored a damage due to incorrect target/source!")
	else
		dealingInstance = null // let no one else retrieve the same instance
	return d

function handler() returns bool
	let damage = GetEventDamage()
	if damage == 0
		return false
		
	var d = retrieve()
	if d == null
		d = getDamageFromEvent()
	else
		d.setAmount(damage)
	
	d.state = DamageState.ACQUIRED
	
	for i = 0 to d.modifyCount
		d.state = DamageState.MODIFYING
		for modifier in damageModifiers
			modifier.modify(d)
		d.state = DamageState.ACQUIRED
	
	if d.doDeflect
		d.actualAmount = 0
	else
		let life = d.getTarget().getHP()
		d.killedTarget = life - .406 < d.getAmount()
		if d.killedTarget 
			if d.doPreventDeath
				d.killedTarget = false
				d.actualAmount = life - .406
			else
				d.actualAmount = life
		else
			d.actualAmount = d.getAmount()

		if d.actualAmount < 0
			d.actualAmount = 0
	BlzSetEventDamage(d.actualAmount)

	d.state = DamageState.LISTENING
	for listener in damageListeners
		listener.listen(d)
	d.state = DamageState.FIRED

	if previousDamage != null and not previousDamage.isReturned
		destroy previousDamage
	previousDamage = d
	
	Log.trace("finish d" + I2S(d castTo int))
	return false

init
	addOnDamageFunc(Condition(function handler))
