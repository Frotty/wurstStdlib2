package DamageModify
import DamageDetection
import LinkedList
import HashSet
import DamageType
/*	
	// Overview
	This system brings the best features from damage systems created in vJass
	to wurst, while also adding own functionality and providing solutions to
	several problems.

	Features:
	- class Damage, containing every argument of `UnitDamageTarget` native
		- Most of them are unknown if damage is non-triggered, though
		- instances have 
	- Consistent access to Damage instance before, during and after the event
	- additional `data` field 
	- Listeners and Modifiers, a closure types to process the event
		- Them are separate because listeners are disabled to modify, but are
			guaranteed to process event once. 
	- Access to initial, convieved and actual damage amount
		- actual damage means how much HP target lost
	- Fix to recursed event processing order

	// Basic usage

	There's Modifiers and Listeners that can be used to process damage events.
	Modifiers are run before Listeners.

	So here's some examples to demonstrate basic functional of this system.
	Note: all getters are inlined.

	Damage amplification debuff.
	addDamageModifier() damage ->
		if damage.getTarget().hasAbility(DEBUFF_ID)
			damage.addMultiplier(1.25)
	
	Passive block ability.
	addDamageModifier() damage ->
		if damage.getTarget().hasAbility(BLOCK_ID)
			damage.addAmount(-12) // Won't modify below 0.

	Damage displaying snippet.
	addDamageListener() damage ->
		if IsUnitVisible(damage.getTarget(), localPlayer)
			createCriticalStrikeTextTag(damage.getTarget(), damage.getActual())
			..setColor(damage.getSource().getColor().toColor().withAlpha(255))

	Spell that is modified twice.
	registerSpellEffectEvent(ARCANE_BLAST_ID) ->
		new Damage(GetTriggerUnit(), GetSpellTargetUnit(), BLAST_DAMAGE, ATTACK_TYPE_NORMAL, 0, false)..setModifyCount(2)..deal()

	Spell with pure damage.
	registerSpellEffectEvent(FINGER_ID) ->
		new Damage(GetTriggerUnit(), GetSpellTargetUnit(), FINGER_DAMAGE, ATTACK_TYPE_NORMAL, 0, false)..setModifyCount(0)..deal()

	If these examples would be used together in one map, then blast would display
	`BLAST_DAMAGE * 1.25^2 - 24` damage to debuffed unit with block,
	while Finger of Death would display `FINGER_DAMAGE` damage to the same unit.

	Considering it had enough health to withstand the damage, because actual
	damage is capped. to target's HP.

	// Advanced usage

	Damage instance can be created before damage invokation,
	thus it can be modified anyhow before the event.

		// Instance lifetime manipulation
	By default, any Damage instance is automatically destroyed throughout
	the damage event. But should user invoke .deal() with argument `false`,
	the Damage won't be destroyed and thus it would be possible to easily retrieve
	damage outcome: whether exactly this has killed the target, how much HP did
	it loss, how much the damage was modified.

	This broadens possibilities in designing of unique abilities while creating
	no overhead at all. Just don't forget to free the instance in the end.

	Here's an example of a leeching ability that can't leech more than targets HP.
	registerSpellEffectEvent(LEECH_ID) ->
		let d = new Damage(GetTriggerUnit(), GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, 0)

		d.getSource().addHP(d.getActual()) // Heal is capped at target's hp
		d.getSource().addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		destroy d

		// Damage recursion
	It is strongly recommended to use system's functionality in case you would
	want to damage something during damage event. This system manages damage recursion
	in such way that new damage events happen after it's origin has been processed,
	while default way is to process new damage right where it has been called.

	Damage 1 is calling damage 2 from inside it's own listeners.
	
	Default way:
	1 is called
	1 starts processing
		2 is called
		2 starts processing
		2 ends processing
	1 ends processing
	
	Fixed way:
	1 is called
	1 starts processing
	1 ends processing

	2 is called
	2 starts processing
	2 ends processing

		// Data carrying
	There's one additional integer field for the damage.
	
	An example usage would be to put spell id that caused the damage to track
	exact sources of damage for unit, to mimic Dota 2's fight recaps.

	// Specification

	It is guaranteed that created Damage instance would be the same that will be
	processed in event handler, thus same for modifiers and listeners; any changes
	will reflect in original local variable accessable in case instance were not
	autodestroyed.

	System is guaranteed to work as in documentation only if there's no listeners
	in DamageDetection after this package's one.
	The system does not handle initial 0 damage events unless you change configuration.
	You cannot modify damage amount below 0.
	
	Has several cases of possibly unexpected behavior:
	- Actual amount can not go below zero or above target's HP.
	- Event Damage is set to .actualAmount, not .amount.
	- Damage instance can not be modified from inside listeners.

*/

// Configuration

/** If Damage instance wasn't created by one of DamageModify package's functions
	(or `new Damage(...)`), then Damage.data would be set to this value */
@configurable public constant DAMAGE_NONTRIGGERED_DATA = -1

/** Maximum amount of damage events that can happen in a single event */
@configurable public constant RECURSION_TRESHOLD = 32

/** Describes default way to create Damage instance if damage event doesn't
	correspond to any Damage instance. */
@configurable function getDamageFromEvent() returns Damage
	return GetEventDamage() == 0 ? null : new Damage(GetEventDamageSource(), GetTriggerUnit(), GetEventDamage(), false, false, getDamageType() == DamageType.SPELL ? ATTACK_TYPE_NORMAL : ATTACK_TYPE_CHAOS, null, null, DAMAGE_NONTRIGGERED_DATA)

/** Should return whether retrieved Damage data matches event data. Is used to
	check triggered damage  */
@configurable function Damage.compareWithEventData() returns bool
	return this.getSource() == GetEventDamageSource() or this.getTarget() == GetTriggerUnit()

// Wrappers for unit.damageTarget with data attachment

/** Deals triggered damage from unit to target. Additional data can be specified.

	Is a helper for `new Damage(*args*, false)..deal()`, where last
	arg specifies whether the instance should not be destroyed during the event.
	If you need instance after it has been dealt, create it manually. */
public function unit.damageTarget(unit target, real amount, bool attack, bool ranged, attacktype attackType, damagetype damageType, weapontype weaponType, int data)
	new Damage(this, target, amount, attack, ranged, attackType, damageType, weaponType, data)..deal()

public function unit.damageTarget(unit target, real amount, attacktype attackType, int data)
	this.damageTarget(target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

public function unit.damageTarget(unit target, real amount, int data)
	this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

Damage previousDamage = null
Damage dealingInstance = null

let queue = new LinkedList<Damage>
int recursionAmount = 0
bool needTimer = false
bool dequeueRunning = false
timer nullTimer = CreateTimer()

/** Returns the damage instance that was created on last Damage event.
	For both listeners and modifiers it is previous to callback argument.

	Allows to retrieve the instance right after unit.damageTarget() call,
	but it is not guaranteed. */
public function getPreviousDamage() returns Damage
	return previousDamage

// Callbacks with direct Damage instance acquirement

/** These callbacks are used to modify the damage.

	They can be called zero or more times, so that their call is not guaranteed
	for every instance, still the usual case is one time per instance. */
public interface DamageModifier
	function modify(Damage d)

/** These callbacks are used to listen to the damage.

	They are called strictly once per every damage instance, guaranteed,
	but they are disabled to modify. */
public interface DamageListener
	function listen(Damage d)

let damageModifiers = new HashSet<DamageModifier>

let damageListeners = new HashSet<DamageListener>

public function addDamageModifier(DamageModifier cb) returns DamageModifier
	damageModifiers.add(cb)
	return cb

public function removeDamageModifier(DamageModifier cb)
	damageModifiers.remove(cb)

public function addDamageListener(DamageListener cb) returns DamageListener
	damageListeners.add(cb)
	return cb

public function removeDamageListener(DamageListener cb)
	damageListeners.remove(cb)

enum DamageState
	CREATED // Initial state after creation
	QUEUED // Damage.deal() is called
	FIRING // Damage.invoke() is called
	ACQUIRED // Damage is acquired by damage event handler
	MODIFYING // Damage.modify() is called
	LISTENING // Last processing stage; modifying is forbidden
	FIRED // Damage instance is completely processed by system

public function DamageState.toString() returns string
	switch this
		case CREATED
			return "created"
		case QUEUED
			return "queued"
		case FIRING
			return "firing"
		case ACQUIRED
			return "acquired"
		case MODIFYING
			return "modifying"
		case LISTENING
			return "listening"
		case FIRED
			return "fired"

	return "error"

public class Damage

	/** Custom field which can be pinned damage event */
	integer data

	private unit source
	private unit target
	private bool ranged
	private bool attack
	private attacktype attackType
	private damagetype damageType
	private weapontype weaponType

	/** What amount of damage was originally convieved */
	private real initialAmount
	/** What amount of damage was convieved after modification*/
	private real amount
	/** Final amount of damage event */
	protected real actualAmount = 0
	/** Amount of times that each DamageModifier is applied to this damage. */
	protected int modifyCount = 1

	protected bool doPreventDeath = false
	protected bool doDeflect = false
	
	/** Holds info about damage event state */
	protected DamageState state = DamageState.CREATED
	/** It is set to true if the damage, when it was dealt, killed the target */
	protected bool killedTarget = false

	protected bool autoDestroy = true

	function getSource() returns unit
		return source
	function getTarget() returns unit
		return target
	function getRanged() returns bool
		return ranged
	function getAttack() returns bool
		return attack
	function getAttackType() returns attacktype
		return attackType
	function getDamageType() returns damagetype
		return damageType
	function getWeaponType() returns weapontype
		return weaponType
	function getState() returns DamageState
		return state

	/** If the damage is modified by spell bracers ability. */
	function isSpell() returns bool
		return attackType == ATTACK_TYPE_NORMAL

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return (state == DamageState.FIRED and killedTarget) or (state != DamageState.FIRED and target.getHP() - .406 < amount)

	/** Returns true if the damage have killed target
		Is valid only for listeners and after the event. */
	function hasKilledTarget() returns bool
		if state == DamageState.FIRED or state == DamageState.LISTENING
			return killedTarget

		Log.error("Damage.hasKilledTarget() is used in the wrong damage state:" + state.toString())
		return false

	function getInitial() returns real
		return initialAmount
	
	/** Returns the actual damage that was withdrawn from the unit.
		Becomes valid only for listeners and after the event. */
	function getActual() returns real
		if state != DamageState.FIRED and state != DamageState.LISTENING
			Log.error("Damage.getActual() is used in the wrong damage state:" + state.toString())
		return actualAmount

	function getAmount() returns real
		return amount
	
	/** Returns amount of times that each DamageModifier is applied to this damage.
		
		Defaults to 1, but can be set to range [0, 32]. */
	function getModifyCount() returns int
		return modifyCount
	
	// Manual instance creation

	private function set(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data)
		this.source = source
		this.target = target
		this.initialAmount = amount
		this.amount = amount
		this.ranged = ranged
		this.attack = attack
		this.attackType = attackType
		this.damageType = damageType
		this.weaponType = weaponType
		this.data = data

	/** Allows manual creation of Damage instance, which is then dealt
		through .deal() call, guaranteed passing it to modifiers and listeners.

		You can attach anything to Damage instance with .data field. */
	construct(unit source, unit target, real amount, bool ranged, bool attack, attacktype attackType, damagetype damageType, weapontype weaponType, int data)
		set(source, target, amount, ranged, attack, attackType, damageType, weaponType, data)

	construct(unit source, unit target, real amount, attacktype attackType, int data)
		set(source, target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)
	
	construct(unit source, unit target, real amount, int data)
		set(source, target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

	ondestroy
		if state != DamageState.CREATED or state != DamageState.FIRED
			Log.error("destroy Damage is used in the wrong damage state:" + state.toString())

	/** applies user-created Damage instance, instantly processing it through
		all damage events. After this function is called, the Damage will be
		in 'fired' state. */
	function deal()
		deal(true)

	/** applies user-created Damage instance, instantly processing it through
		all damage events. After this function is called, the Damage will be
		in 'fired' state.
		
		autoDestroy decides whether or not should the instance be destroyed
		after event processing. */
	function deal(bool autoDestroy)
		if state == DamageState.CREATED
			this.autoDestroy = autoDestroy
			// What is described in hotdoc happens in .invoke()
			// While this is a wrapper to handle recursive damage properly
			if recursionAmount > RECURSION_TRESHOLD
				Log.warn("Damage.deal(): Recursion treshold has been hit.")
				return
			state = DamageState.QUEUED
			queue.push(this)
			if not dequeueRunning
				dequeueRunning = true
				if needTimer
					nullTimer.start(0, function dequeue)
				else
					dequeue()
		else
			Log.error("Damage.deal() is used in the wrong damage state:" + state.toString())			

	protected function invoke()
		state = DamageState.FIRING
		let temp = dealingInstance
		dealingInstance = this
		Log.trace("deal d" + (this castTo int).toString())
		UnitDamageTarget(source, target, amount, attack, ranged, attackType, damageType, weaponType)
		Log.trace("completed d" + (this castTo int).toString())
		dealingInstance = temp
		if state != DamageState.FIRED
			Log.error("Damage.deal() returned not fully processed damage! (state: " + state.toString() + ")")
			if autoDestroy
				destroy this
			
	// Event modification

	/** Make actual amount leave target at at least 0.406 hp left */
	function preventDeath()
		doPreventDeath = true

	/** Nullifies actual amount no matter what. */
	function deflect()
		doDeflect = true

	/** Increases `amount` of the damage by `initialAmount * magnitude` */
	function addMultiplier(real magnitude)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			amount += initialAmount * (magnitude - 1)
		else
			Log.error("Damage.addMultiplier() is used in the wrong damage state:" + state.toString())			

	/** Increases `amount` of the damage with given amount */
	function addAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount += amount
		else
			Log.error("Damage.addAmount() is used in the wrong damage state:" + state.toString())			

	/** Sets `amount` of the damage to given amount */
	function setAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount = amount
		else
			Log.error("Damage.setAmount() is used in the wrong damage state:" + state.toString())

	/** Sets the amount of times that each DamageModifier is applied to this damage.
		Should be in range [0, 32]. */
	function setModifyCount(int val)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			if val >= 0 and val <= 32
				modifyCount = val
			else
				Log.error("Damage.setModifyCount() is used with wrong value: " + val.toString())
		else
			Log.error("Damage.setModifyCount() is used in the wrong damage state:" + state.toString())
				

// Handler of the event

function dequeue()
	while true
		let next = queue.dequeue()
		if next == null
			break
		next.invoke()
	dequeueRunning = false
	recursionAmount = 0
	needTimer = false

function retrieve() returns Damage
	var d = dealingInstance
	if not d.compareWithEventData()
		Log.warn("Damage.retrieve() has ignored a damage due to incorrect data!")
		d = null
	if d != null
		dealingInstance = null // let no one else retrieve the same instance
	return d

function handler() returns bool
	real damage_ratio = 1
	var damage = retrieve()
	if damage == null
		damage = getDamageFromEvent()

		if damage == null
			return false

		if recursionAmount == 0
			needTimer = true
		else
			Log.error("Non-triggered damage recursion detected.")
	else
		damage_ratio = GetEventDamage() / damage.getInitial()
	
	recursionAmount += 1
	damage.state = DamageState.ACQUIRED
	
	for i = 0 to damage.modifyCount
		damage.addMultiplier(damage_ratio)
		damage.state = DamageState.MODIFYING
		for modifier in damageModifiers
			modifier.modify(damage)
		damage.state = DamageState.ACQUIRED
	
	if damage.doDeflect
		damage.actualAmount = 0
	else
		let life = damage.getTarget().getHP()
		damage.killedTarget = life - .406 < damage.getAmount()
		if damage.killedTarget 
			if damage.doPreventDeath
				damage.killedTarget = false
				damage.actualAmount = life - .406
			else
				damage.actualAmount = life
		else
			damage.actualAmount = damage.getAmount()

		if damage.actualAmount < 0
			damage.actualAmount = 0
	BlzSetEventDamage(damage.actualAmount)

	damage.state = DamageState.LISTENING
	for listener in damageListeners
		listener.listen(damage)
	damage.state = DamageState.FIRED

	if previousDamage != null and previousDamage.autoDestroy
		destroy previousDamage
	previousDamage = damage

	if not dequeueRunning
		recursionAmount = 0
	
	Log.trace("finish damage" + (damage castTo int).toString())
	return false

init
	addOnDamageFunc(Condition(function handler))
