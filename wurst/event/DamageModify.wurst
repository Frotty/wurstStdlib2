package DamageModify
import DamageDetection
import LinkedList
import DamageType
/*
	The main objective of this system is to have same damage event-related object at all stages of damage event.
	It implements `Damage` class which contains all arguments of `UnitDamageTarget` native plus one integer for additional attachments.
	Features custom instance lifetime.
	Callbacks have Damage instance as an argument.

	Damage instance can be created before damage invokation, thus it can be modified anyhow before the event.
	It is guaranteed to be passed to modifiers and listeners during the event invoked through `.deal()` method.
	And then the instance is still accessable (in case it was saved), allowing user to easily retrieve event data.

	System is guaranteed to work as in documentation only if there's no listeners in DamageDetection after this package's one.
	The system does not handle 0 damage events.
	
	Has several cases of possibly unexpected behavior:
	- Actual amount can not go below zero or above target's HP.
	- Event Damage is set to .actualAmount, not .amount.
	- Damage instance can not be modified from inside listeners.

	There will be output to debug log stream if anything would go wrong,
	for example if system will fail to pass/catch Damage instance in between
	damage instance creation and it's handling (.deal() and .handle()).
	
	Examples:
	
	// Leech implementation #1
	function onLeechEffect1()
		// Using wrapper from the package, event data is retrieved easily.
		let d = GetTriggerUnit().damageTarget(GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, 0)

		d.source.addHP(d.getActual()) // Heal is capped at target's hp
		d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		d.releaseInstance() // Don't forget to free the instance

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect1)

	// Leech implementation #2
	function onLeechEffect2()
		GetTriggerUnit().damageTarget(GetSpellTargetUnit(), LEECH_DAMAGE, ATTACK_TYPE_NORMAL, LEECH_ID)

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
		addDamageListener() d ->
			if d.data == LEECH_ID
				d.source.addHP(d.getActual())
				d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Simple damage resistance buff
	import UniqueDamageListening

	function onBuffEffect()
		let target = GetSpellTargetUnit()
		let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
		let cb = addTargetDamageModifier() d ->
			d.amount -= d.initialAmount * .5
		doAfter(BUFF_DURATION) ->
			removeTargetDamageModifier(cb)
			effect.destr()

	init
		registerSpellEffectEvent(BUFF_ID, function onLeechEffect2)
*/

// Configuration

/** If Damage instance wasn't created by one of DamageModify package's functions
	(or `new Damage(...)`), then Damage.data would be set to this value */
@configurable public constant DAMAGE_NONTRIGGERED_DATA = -1

/** Describes default way to create Damage instance if damage event doesn't
	correspond to any Damage instance. */
@configurable function getDamageFromEvent() returns Damage
	return new Damage(GetEventDamageSource(), GetTriggerUnit(), GetEventDamage(), false, false, getDamageType() == DamageType.SPELL ? ATTACK_TYPE_NORMAL : ATTACK_TYPE_CHAOS, null, null, DAMAGE_NONTRIGGERED_DATA)

// Wrappers for unit.damageTarget with data attachment

/** Deals triggered damage from unit to target. Additional data can be specified.
	Damage instance with all arguments is saved and returned after being dealt,
	so don't forget to call .releaseInstance() on it.

	Is a helper for `new Damage(*args*)..saveInstance()..modify()..deal()` */
public function unit.damageTarget(unit target, real amount, bool attack, bool ranged, attacktype attackType, damagetype damageType, weapontype weaponType, int data) returns Damage
	return new Damage(this, target, amount, attack, ranged, attackType, damageType, weaponType, data)..saveInstance()..modify()..deal()

public function unit.damageTarget(unit target, real amount, attacktype attackType, int data) returns Damage
	return this.damageTarget(target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

public function unit.damageTarget(unit target, real amount, int data) returns Damage
	return this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

// Callbacks with direct Damage instance acquirement

/** These callbacks are used to modify the damage.

	They can be called zero or more times, so that their call is not guaranteed
	for every instance, still the usual case is one time per instance. */
public interface DamageModifier
	function modify(Damage d)

/** These callbacks are used to listen to the damage.

	They are called strictly once per every damage instance, guaranteed,
	but they are disabled to modify. */
public interface DamageListener
	function listen(Damage d)

let damageModifiers = new LinkedList<DamageModifier>

let damageListeners = new LinkedList<DamageListener>

public function addDamageModifier(DamageModifier cb) returns DamageModifier
	damageModifiers.add(cb)
	return cb

public function removeDamageModifier(DamageModifier cb)
	damageModifiers.remove(cb)

public function addDamageListener(DamageListener cb) returns DamageListener
	damageListeners.add(cb)
	return cb

public function removeDamageListener(DamageListener cb)
	damageListeners.remove(cb)

// The wrapper class

enum DamageState
	CREATED // Initial state after creation
	FIRING // Damage.deal() is called
	ACQUIRED // Damage is acquired by damage event handler
	MODIFYING // Damage.modify() is called
	LISTENING // Last processing stage; modifying is forbidden
	FIRED // Damage instance is completely processed by system

public function DamageState.toString() returns string
	switch this
		case CREATED
			return "created"
		case FIRING
			return "firing"
		case ACQUIRED
			return "acquired"
		case MODIFYING
			return "modifying"
		case LISTENING
			return "listening"
		case FIRED
			return "fired"

	return "error"
	
public class Damage

	// Event info

	/** Custom field which can be pinned damage event */
	integer data

	private unit source
	private unit target
	private bool ranged
	private bool attack
	private attacktype attackType
	private damagetype damageType
	private weapontype weaponType

	/** What amount of damage was originally convieved */
	private real initialAmount
	/** What amount of damage was convieved after modification*/
	private real amount
	/** Final amount of damage event */
	protected real actualAmount = 0
	
	/** Holds info about damage event state */
	protected DamageState state = DamageState.CREATED
	/** It is set to true if the damage, when it was dealt, killed the target */
	protected bool killingBlow = false

	function getSource() returns unit
		return source
	function getTarget() returns unit
		return target
	function getRanged() returns bool
		return ranged
	function getAttack() returns bool
		return attack
	function getAttackType() returns attacktype
		return attackType
	function getDamageType() returns damagetype
		return damageType
	function getWeaponType() returns weapontype
		return weaponType
	function getState() returns DamageState
		return state

	/** If the damage is modified by spell bracers ability. */
	function isSpell() returns bool
		return attackType == ATTACK_TYPE_NORMAL

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return (state == DamageState.FIRED and killingBlow) or (state != DamageState.FIRED and target.getHP() - .406 < amount)

	function getInitial() returns real
		return initialAmount
	/** Returns the actual damage that was withdrawn from the unit.
		Becomes valid only for listeners and after the event. */
	function getActual() returns real
		return actualAmount
	function getAmount() returns real
		return amount

	protected static Damage previousDamage = null
	/** Returns the damage instance that was created on last Damage event.
		For both listeners and modifiers it is previous to callback argument.

		Allows to retrieve the instance right after unit.damageTarget() call,
		but it is not guaranteed. */
	static function getPrevious() returns Damage
		return previousDamage

	// Manual instance creation
	
	/** Allows manual creation of Damage instance, which is then dealt
		through .deal() call, guaranteed passing it to modifiers and listeners.

		Consider also .saveInstance() and .modify() before it's call. */
	construct(unit _source, unit _target, real _amount, bool _ranged, bool _attack, attacktype _attackType, damagetype _damageType, weapontype _weaponType, int _data)
		source = _source
		target = _target
		initialAmount = _amount
		amount = _amount
		ranged = _ranged
		attack = _attack
		attackType = _attackType
		damageType = _damageType
		weaponType = _weaponType
		data = _data
			
	protected static Damage dealingInstance = null
	/** applies user-created Damage instance, allowing it to be retrieved
		through Damage.retrieve() funciton. */
	function deal()
		if state == DamageState.CREATED
			state = DamageState.FIRING
			saveInstance() // will be released after processing
			let temp = dealingInstance
			dealingInstance = this
			Log.trace("deal d" + I2S(this castTo int))
			UnitDamageTarget(source, target, amount, attack, ranged, attackType, damageType, weaponType)
			Log.trace("completed d" + I2S(this castTo int))
			dealingInstance = temp
			if state != DamageState.FIRED
				Log.debug("Damage.deal() returned not fully processed damage! (state: " + state.toString() + ")")
				releaseInstance()
		else
			Log.debug("Damage.deal() called on already dealt damage!")

	/** Damage instances are automatically destroyed.
		Use this to protect them if you need an instance anyhow.
		
		You need then to use `releaseInstance()`
		in order to destroy the instance.

		This means that the instance will be destroyed
		when the last `releaseInstance()` is called on it */
	function saveInstance()
		wantSave += 1

	/** Releases Damage instance so it can be destroyed.
		It is destroyed immediately if nobody else had saved it */
	function releaseInstance()
		wantSave -= 1
		if wantSave <= 0
			destroy this

	/** The counter inside saveInstance() and releaseInstance() */
	protected int wantSave = 0
	ondestroy
		if wantSave > 0
			Log.error("Damage instance was destroyed unsafely! Use .releaseInstance() instead!")

	protected static function retrieve() returns Damage
		var d = Damage.dealingInstance
		if d == null or d.source != GetEventDamageSource() or d.target != GetTriggerUnit()
			if d != null
				Log.debug("Damage.handler() was ignored a damage due to incorrect target/source!")
		else
			Damage.dealingInstance = null // let no one else retrieve the same instance
		return d

	// Event modification

	/** applies all modifiers to the damage instance once */
	function modify()
		if state != DamageState.FIRED and state != DamageState.LISTENING and state != DamageState.MODIFYING
			let tempState = state
			state = DamageState.MODIFYING
			for i in damageModifiers
				i.modify(this)
			state = tempState

	/** Make actual amount leave target at at least 0.406 hp left */
	function preventDeath()
		doPreventDeath = true
	protected bool doPreventDeath = false

	/** Nullifies actual amount no matter what. */
	function deflect()
		doDeflect = true
	protected bool doDeflect = false

	/** Increases `amount` of the damage by `initialAmount * magnitude` */
	function addMultiplier(real magnitude)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			amount += initialAmount * (magnitude - 1)
		else
			Log.debug("Damage.addMultiplier() cannot modify fired instances!")

	/** Increases `amount` of the damage with given amount */
	function addAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount += amount
		else
			Log.debug("Damage.addAmount() cannot modify fired instances!")

	/** Sets `amount` of the damage to given amount */
	function setAmount(real amount)
		if state != DamageState.FIRED and state != DamageState.LISTENING
			this.amount = amount
		else
			Log.debug("Damage.setAmount() cannot modify fired instances!")

// Handler of the event

function handler() returns bool
	let damage = GetEventDamage()
	if damage == 0
		return false
		
	var d = Damage.retrieve()
	if d == null
		d = getDamageFromEvent()..saveInstance()
			..modify() // So basically all non-triggered damage is modified once
	else
		d.setAmount(damage)
	
	d.state = DamageState.ACQUIRED
	
	if d.doDeflect
		d.actualAmount = 0
	else
		let life = d.getTarget().getHP()
		d.killingBlow = life - .406 < d.getAmount()
		if d.killingBlow 
			if d.doPreventDeath
				d.killingBlow = false
				d.actualAmount = life - .406
			else
				d.actualAmount = life
		else
			d.actualAmount = d.getAmount()

		if d.actualAmount < 0
			d.actualAmount = 0
	BlzSetEventDamage(d.actualAmount)

	d.state = DamageState.LISTENING
	for i in damageListeners
		i.listen(d)
	d.state = DamageState.FIRED

	if Damage.previousDamage != null
		Damage.previousDamage.releaseInstance()
	Damage.previousDamage = d
	
	Log.trace("finish d" + I2S(d castTo int))
	return false

init
	addOnDamageFunc(Condition(function handler))
