package DamageModify
import TimerUtils
import AbilityObjEditing
import ClosureForGroups
import DamageDetection
import OnUnitEnterLeave
import ObjectIdGenerator
import LinkedList

@configurable public constant DAMAGE_ID_NONTRIGGERED = -1

public interface ForDamageCallback
	function run(Damage d)

LinkedList<ForDamageCallback> damageModifiers = new LinkedList<ForDamageCallback>
public function addDamageModifier(ForDamageCallback cb)
	damageModifiers.add(cb)
public function removeDamageModifier(ForDamageCallback cb)
	damageModifiers.remove(cb)

LinkedList<ForDamageCallback> damageListeners = new LinkedList<ForDamageCallback>
public function addDamageListener(ForDamageCallback cb)
	damageListeners.add(cb)
public function removeDamageListener(ForDamageCallback cb)
	damageListeners.remove(cb)

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions. */
public function unit.damage(unit target, real amount, bool spell, int id)
	new Damage(this, target, amount, spell, id)..modify()..deal()

/** Deals triggered damage from unit to target. */
public function unit.damage(unit target, real amount, bool spell)
	new Damage(this, target, amount, spell, 0)..modify()..deal()
/** Deals triggered spell damage from unit to target. */
public function unit.damage(unit target, real amount)
	new Damage(this, target, amount, true, 0)..modify()..deal()

public class Damage
	integer id
	unit source
	unit target
	bool spell
	real initial
	real amount

	/** check this if you want to save target from damage */
	bool saveTarget = false
	
	/** stores how much health were added */
	protected real afterDamage = 0.
	protected bool killingBlow = false
	private bool fired = false
	/** check this if damage instance is needed elsewhere before .deal(), though you'll need to delete this manually */
	int wantSave = 0

	/** applied all modifiers to the damage instance once */
	function modify()
		for i in damageModifiers
			i.run(this)
	protected function anounce()
		for i in damageListeners
			i.run(this)

	function isKillingBlow() returns bool
		return (not fired and target.getHP() - .405 < amount) or killingBlow
		
	private construct()
	protected static function processEvent() returns Damage
		let damage = GetEventDamage()
		if damage == 0
			return null
		let d = new Damage()
		d.id = DAMAGE_ID_NONTRIGGERED
		d.source = GetEventDamageSource()
		d.target = GetTriggerUnit()
		d.initial = GetEventDamage()
		d.spell = d.initial < 0
		if d.spell
			d.initial = -d.initial
		d.amount = d.initial
		d.fired = true
		return d

	construct(unit source, unit target, real amount, bool isSpell, int id)
		this.source = source
		this.target = target
		this.initial = amount
		this.amount = amount
		spell = isSpell
		this.id = id

	function deal()
		if not fired
			fired = true
			if target.isAlive()
				let life = target.getHP()
				killingBlow = life - .405 < amount
				if killingBlow and saveTarget
					amount = target.getHP() - .406
					killingBlow = false			
				dealCodeDamage(source, target, amount, killingBlow)
				anounce()
			if this.wantSave == 0
				destroy this

// ConvertAttackType(7) is a hidden attack type with some unique properties. For
// more information see goo.gl/9k8tn .
constant ATTACK_TYPE_UNIVERSAL = ConvertAttackType(7)
constant DAMAGE_TYPE_CHECK_ID = compiletime(ABIL_ID_GEN.next())
constant CHEAT_DEATH_ID = compiletime(ABIL_ID_GEN.next())

/** Deal an exact amount of damage to `target`, crediting kill experience and
	gold bounty to `attacker` and not triggering any of DamageDetection listeners. Isn't supposed to use outside of the system. */
function dealCodeDamage(unit attacker, unit target, real damage, bool killingBlow)
	if damage != 0
		let hp = target.getHP()
		disableDamageDetect()
		if not killingBlow
			target.setHP(max(hp - damage, .405))
			UnitDamageTarget(attacker, target, 0. , true, false, ATTACK_TYPE_UNIVERSAL, DAMAGE_TYPE_UNIVERSAL, null) // Is it ever doing something?
		else
			// Deal damage using two separate components. The ATTACK_TYPE_UNIVERSAL
			// case will deal damage to units of all armor types, even if that armor
			// would otherwise block all damage. The ATTACK_TYPE_MAGIC case affect
			// ethereal units, whereas other attack types do not.
			UnitDamageTarget(attacker, target, 1000000. + (hp + damage) * 2, true, false, ATTACK_TYPE_UNIVERSAL, DAMAGE_TYPE_UNIVERSAL, null)
			UnitDamageTarget(attacker, target, 1000000. + (hp + damage) * 2, true, false, ATTACK_TYPE_MAGIC,	 DAMAGE_TYPE_UNIVERSAL, null)
		enableDamageDetect()


function after()
	let	 time	= GetExpiredTimer()
	Damage d = time.getData() castTo Damage

	d.target.removeAbility(CHEAT_DEATH_ID)
	dealCodeDamage(d.source, d.target, d.afterDamage, d.killingBlow)
	
	d.anounce()

	if d.wantSave == 0
		destroy d
	time.release()

function handler() returns bool
	let d = Damage.processEvent()
	if d == null
		return false
	
	d.modify()

	let life = d.target.getHP()
	d.killingBlow = life - .405 < d.amount
	if d.killingBlow and d.saveTarget
		d.amount = life - .406
		d.killingBlow = false
	
	if d.killingBlow
		// So the unit should die no matter what. The following line should secure it.
		d.amount = life // A bit of logic wc3 does not have - damage can't be greater than unit's life.
		dealCodeDamage(d.source, d.target, life + d.initial + d.amount, true) // DIE, INSECT!!!
		d.anounce()
	else
		// So the unit should survive no matter what.
		if d.spell
			// After all: life += -d.amount - d.initial // + d.initial from event
			if life - d.initial - d.amount < .405
				d.afterDamage = d.initial + d.amount
				getTimer()..setData(d castTo int)
						..start(0., function after)
			else
				d.target.setHP(life - d.initial - d.amount)
				d.anounce()
		else
			// After all: life += -d.amount + d.initial // - d.initial from event 
			if life + d.initial - d.amount > d.target.getMaxHP()
				d.target.addAbility(CHEAT_DEATH_ID)
				d.target.setHP(life + d.initial - d.amount)
				getTimer()..setData(d castTo int)
				..start(0., function after)
			else
				d.target.setHP(life + d.initial - d.amount)
				d.anounce()

	return false


init
	onEnter() ->
		getEnterLeaveUnit()..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	forUnitsInRect(bj_mapInitialPlayableArea) u ->
		u..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	addOnDamageFunc(Condition(function handler))

@compiletime function generateAbility()
	new AbilityDefinitionRunedBracers(DAMAGE_TYPE_CHECK_ID)
		..setName("Runed Bracer Dummy")
		..setEditorSuffix("(DamageType)")
		..setItemAbility(false)
		..setDamageReduction(1, 2.)
	new AbilityDefinitionAIhe(CHEAT_DEATH_ID)
		..setName("Cheat Death Dummy")
		..setEditorSuffix("(Damage)")
		..setItemAbility(false)
		..setHitPointsGained(1, 1000000)