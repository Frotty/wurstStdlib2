/**
	DamageModify
	by Trokkin

	API:

	// Pretty much '(Damage d) -> ...'
	interface ForDamageCallback
		run(Damage d)

	// these are called before the damage is dealt
	// can be called multiple amount of times or not called at all
	addDamageModifier(ForDamageCallback cb)
	removeDamageModifier(ForDamageCallback cb)
	
	// these are called after the damage is dealt
	// are called strictly once per damage instance
	addDamageListener(ForDamageCallback cb)
	removeDamageListener(ForDamageCallback cb)

	// a short for 'new Damage(this, target, amount, isSpell, id)..modify()..deal()'
	unit.damage(unit target, real amount, OPTIONAL bool isSpell = true, int id = 0)

	class Damage
		
		// Basic damage event info
		unit source
		unit target
		bool spell
		real initial

		// .id is used for any unique iterations
		integer id
		// .amount is used to manipulate damage amount
		// like, addDamageModifier(d -> d.amount += d.initial * 1.00) adds +100% multiplier onto damage
		real amount

		// if .saveTarget is checked then .target will survive from this damage no matter what
		bool saveTarget = false

		// after damage has happened the Damage object is destroyed, but only if wantSave == 0
		// which should happen only if other system would want to save it and destroy it manually
		// (even then destroy should reduce .wantSave by 1 and check if it's not positive number if other system still wants it)
		// (probably something like counter in Link class from Java)
		int wantSave = 0

		// .modify() evaluates all damageModifiers on itself
		// is automatically called on non-triggered damage once
		// isn't called on manual construction, so user can manually decide how many iterations a damage should have, from 0 to infinity
		modify()

		// Returns true if the damage is going to kill or already have killed target
		isKillingBlow() -> bool

		// Damage objects can be created manually to have full control on them from the code
		construct(unit source, unit target, real amount, bool isSpell, int id)
		// .deal() runs manually created damage
		deal()

	// an important note:
	// for damageListeners .amount is set to actual difference in target's life
	// so damage won't be more than target's life if it has killed target (or it was saved)
	// (a unit has 10 hp, it takes 100 damage, for damageModifiers it's 100 damage
		but for damageListeners it's 10 damage / 10 - .405 damage if .saveTarget == true)

	Examples:
	
	// Leech ability
		constant int LEECH_ID = compiletime(ABIL_ID_GEN.next())
		constant int LEECH_DAMAGE = compiletime(GetRandomInt(100, 200)) // just for lulz

		// Implementation #1
		function onLeechEffect1()
			let d = new Damage(GetTriggerUnit(), GetSpellTargetUnit(), LEECH_DAMAGE, true, 0)..modify()
			d.wantSave += 1
			d.deal()

			d.source.addHP(d.amount) // Leech effect implementation #1
			d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

			d.wantSave -= 1
			if d.wantSave <= 0
				destroy d

		// Implementation #2
		function onLeechEffect2()
			GetTriggerUnit().damage(GetSpellTargetUnit(), LEECH_DAMAGE, LEECH_ID)
		
		init
			addDamageListener() d ->
				if d.id == LEECH_ID	
					d.source.addHP(d.amount) // Leech effect implementation #2
					d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Damage resistance buff
		constant BUFF_DURATION = 5.0

		function onBuffEffect()
			let target = GetSpellTargetUnit()
			let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
			ForDamageCallback cb = () d ->
				if target == d.target
					d.amount -= d.initial * .5
			addDamageModifier(cb)
			doAfter(BUFF_DURATION) ->
				removeDamageModifier(cb)
				effect.destr()

*/
package DamageModify
import AbilityObjEditing
import ClosureForGroups
import DamageDetection
import OnUnitEnterLeave
import ObjectIdGenerator
import LinkedList
import ClosureTimers

@configurable public constant DAMAGE_ID_NONTRIGGERED = -1

public interface ForDamageCallback
	function run(Damage d)

let damageModifiers = new LinkedList<ForDamageCallback>
public function addDamageModifier(ForDamageCallback cb)
	damageModifiers.add(cb)
public function removeDamageModifier(ForDamageCallback cb)
	damageModifiers.remove(cb)

let damageListeners = new LinkedList<ForDamageCallback>
public function addDamageListener(ForDamageCallback cb)
	damageListeners.add(cb)
public function removeDamageListener(ForDamageCallback cb)
	damageListeners.remove(cb)

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions. */
public function unit.damage(unit target, real amount, bool spell, int id)
	new Damage(this, target, amount, spell, id)..modify()..deal()

/** Deals triggered damage from unit to target. */
public function unit.damage(unit target, real amount, bool spell)
	new Damage(this, target, amount, spell, 0)..modify()..deal()
/** Deals triggered spell damage from unit to target. */
public function unit.damage(unit target, real amount)
	new Damage(this, target, amount, true, 0)..modify()..deal()

// ConvertAttackType(7) is a hidden attack type with some unique properties. For
// more information see goo.gl/9k8tn .
constant ATTACK_TYPE_UNIVERSAL = ConvertAttackType(7)
constant DAMAGE_TYPE_CHECK_ID = compiletime(ABIL_ID_GEN.next())
constant CHEAT_DEATH_ID = compiletime(ABIL_ID_GEN.next())

public class Damage
	integer id
	unit source
	unit target
	bool spell
	real initial
	real amount

	/** check this if you want to save target from damage in all cases */
	bool saveTarget = false

	/** check this if damage instance is needed elsewhere before .deal(), though you'll need to delete this manually */
	int wantSave = 0
	
	/** stores how much health were added */
	protected real afterDamage = 0.
	protected bool killingBlow = false
	private bool fired = false

	/** applied all modifiers to the damage instance once */
	function modify()
		for i in damageModifiers
			i.run(this)
	protected function anounce()
		for i in damageListeners
			i.run(this)

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return killingBlow or (not fired and target.getHP() - .405 < amount)
		

	construct(unit source, unit target, real amount, bool isSpell, int id)
		this.source = source
		this.target = target
		this.initial = amount
		this.amount = amount
		spell = isSpell
		this.id = id

	protected static function processEvent() returns Damage
		let damage = GetEventDamage()
		if damage == 0
			return null
		let d = new Damage(GetEventDamageSource(), GetTriggerUnit(), (damage < 0 ? -damage : damage), damage < 0, DAMAGE_ID_NONTRIGGERED)
		d.fired = true
		return d

	/** applies user-created Damage instance. */
	function deal()
		if not fired
			fired = true
			if target.isAlive()
				let life = target.getHP()
				killingBlow = life - .405 < amount
				if killingBlow and saveTarget
					amount = target.getHP() - .406
					killingBlow = false			
				dealCodeDamage(source, target, amount, killingBlow)
				anounce()
			if this.wantSave == 0
				destroy this

/** Deal an exact amount of damage to `target`, crediting kill experience and
	gold bounty to `attacker` and not triggering any of DamageDetection listeners. KillingBlow parameter decides whether to kill the target. Isn't supposed to use outside of the system. */
function dealCodeDamage(unit attacker, unit target, real damage, bool killingBlow)
	if damage != 0
		let hp = target.getHP()
		disableDamageDetect()
		if not killingBlow
			target.setHP(max(hp - damage, .405))
		else
			// Deal damage using two separate components. The ATTACK_TYPE_UNIVERSAL
			// case will deal damage to units of all armor types, even if that armor
			// would otherwise block all damage. The ATTACK_TYPE_MAGIC case affect
			// ethereal units, whereas other attack types do not.
			target.setHP(.405)
			attacker.damageTarget(target, 1000000., ATTACK_TYPE_UNIVERSAL)
			attacker.damageTarget(target, 1000000., ATTACK_TYPE_MAGIC)
		enableDamageDetect()

function handler() returns bool
	let d = Damage.processEvent()
	if d == null
		return false
	
	d.modify()

	let life = d.target.getHP()
	d.killingBlow = life - .405 < d.amount
	if d.killingBlow
		if d.saveTarget
			d.amount = life - .406
			d.killingBlow = false
		else
			// So the unit should die no matter what. The following line should secure it.
			d.amount = life // A bit of logic wc3 does not have - damage can't be greater than unit's life.
			dealCodeDamage(d.source, d.target, life, true) // DIE, INSECT!!!
			d.anounce()
			return false
		
	real rLife
	bool doTimer
	if d.spell
		// After all: life += -d.amount - d.initial // + d.initial from event
		rLife = life - d.initial - d.amount
		doTimer = rLife < .405
		if doTimer
			d.afterDamage = d.initial + d.amount
	else
		// After all: life += -d.amount + d.initial // - d.initial from event 
		rLife = life + d.initial - d.amount
		doTimer = rLife > d.target.getMaxHP()
		if doTimer
			d.target.addAbility(CHEAT_DEATH_ID)
			d.target.setHP(rLife)
			
	if doTimer
		nullTimer() ->
			d.target.removeAbility(CHEAT_DEATH_ID)
			dealCodeDamage(d.source, d.target, d.afterDamage, false)
			
			d.anounce()
		
			if d.wantSave == 0
				destroy d
	else
		d.target.setHP(rLife)
		d.anounce()

	return false

init
	onEnter() ->
		getEnterLeaveUnit()..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	addOnDamageFunc(Condition(function handler))

@compiletime function generateAbility()
	new AbilityDefinitionRunedBracers(DAMAGE_TYPE_CHECK_ID)
		..setName("Runed Bracer Dummy")
		..setEditorSuffix("(DamageType)")
		..setItemAbility(false)
		..setDamageReduction(1, 2.)
	new AbilityDefinitionAIhe(CHEAT_DEATH_ID)
		..setName("Cheat Death Dummy")
		..setEditorSuffix("(Damage)")
		..setItemAbility(false)
		..setHitPointsGained(1, 1000000)