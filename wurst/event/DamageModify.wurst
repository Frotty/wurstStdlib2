/**
	DamageModify

	Never use both this and DamageType package.
	
	API:

	// Essentially used for callback closures taking on the form Damage -> null
	interface ForDamageCallback
		run(Damage d)

	// These adjust effective damage before any has occurred.
	// Can be called zero or more times.
	addDamageModifier(ForDamageCallback cb)
	removeDamageModifier(ForDamageCallback cb)
	
	// these are called after the damage is dealt
	// are called strictly once per damage instance
	addDamageListener(ForDamageCallback cb)
	removeDamageListener(ForDamageCallback cb)

	// a helper for 'new Damage(this, target, amount, isSpell, id)..modify()..deal()'
	unit.damage(unit target, real amount, OPTIONAL bool isSpell = true, int id = 0)

	// a helper for '= new Damage(this, target, amount, isSpell, id)..saveInstance()..modify()..deal()'
	unit.returnDamage(unit target, real amount, bool isSpell, int id) -> Damage

	class Damage
		
		// Basic damage event info
		unit source
		unit target
		bool spell
		real initial

		// .id is used for any unique iterations
		integer id
		// .amount is used to manipulate damage amount
		// like, addDamageModifier(d -> d.amount += d.initial * 1.00) adds +100% multiplier onto damage
		real amount

		// if .saveTarget was called then .target will survive from this damage no matter what
		saveTarget()

		// after damage has happened the Damage object is destroyed if saveInstance() wasn't called
		saveInstance()
		// releaseInstance is used to destroy Damage objects. Use this instead of 'destroy'!
		releaseInstance()

		// Some obvious wrappers
		addAmount(real amount)
		addMultiplier(real mult)

		// .modify() evaluates all damageModifiers on itself
		// is automatically called on non-triggered damage once
		// isn't called on manual construction, so user can manually decide how many iterations a damage should have, from 0 to infinity
		modify()

		// Returns true if the damage is going to kill or already have killed target
		isKillingBlow() -> bool

		// Damage objects can be created manually to have full control on them from the code
		construct(unit source, unit target, real amount, bool isSpell, int id)
		// .deal() runs manually created damage
		deal()

	// an important note:
	// for damageListeners .amount is set to actual difference in target's life
	// so damage won't be more than target's life if it has killed target (or it was saved)
	// (a unit has 10 hp, it takes 100 damage, for damageModifiers it's 100 damage
	// but for damageListeners it's 10 damage / 10 - .405 damage if .doSaveTarget == true)

	Examples:
	
	// Leech ability
		constant int LEECH_ID = compiletime(ABIL_ID_GEN.next())
		constant int LEECH_DAMAGE = compiletime(GetRandomInt(100, 200)) // just for lulz

		// Implementation #1
		function onLeechEffect1()
			let d = GetTriggerUnit().returnDamage(GetSpellTargetUnit(), LEECH_DAMAGE, true, 0)

			d.source.addHP(d.amount) // Leech effect implementation #1
			d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

			d.releaseInstance()

		init
			registerSpellEffectEvent(LEECH_ID, function onLeechEffect1)

		// Implementation #2
		function onLeechEffect2()
			GetTriggerUnit().damage(GetSpellTargetUnit(), LEECH_DAMAGE, LEECH_ID)
	
		init
			registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
			addDamageListener() d ->
				if d.id == LEECH_ID	
					d.source.addHP(d.amount) // Leech effect implementation #2
					d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Damage resistance buff
		constant BUFF_DURATION = 5.0

		function onBuffEffect()
			let target = GetSpellTargetUnit()
			let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
			ForDamageCallback cb = () d ->
				if target == d.target
					d.amount -= d.initial * .5
			addDamageModifier(cb)
			doAfter(BUFF_DURATION) ->
				removeDamageModifier(cb)
				effect.destr()

*/
package DamageModify
import AbilityObjEditing
import DamageDetection
import OnUnitEnterLeave
import ObjectIdGenerator
import LinkedList
import ClosureTimers

@configurable public constant DAMAGE_ID_NONTRIGGERED = -1

public interface ForDamageCallback
	function run(Damage d)

let damageModifiers = new LinkedList<ForDamageCallback>
public function addDamageModifier(ForDamageCallback cb)
	damageModifiers.add(cb)
public function removeDamageModifier(ForDamageCallback cb)
	damageModifiers.remove(cb)

let damageListeners = new LinkedList<ForDamageCallback>
public function addDamageListener(ForDamageCallback cb)
	damageListeners.add(cb)
public function removeDamageListener(ForDamageCallback cb)
	damageListeners.remove(cb)

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions.
	Damage instance is saved and returned after being dealt. */
public function unit.returnDamage(unit target, real amount, bool spell, int id) returns Damage
	return new Damage(this, target, amount, spell, id)..saveInstance()..modify()..deal()

/** Deals triggered damage from unit to target.
	You can specify id if there's any unique id interactions. */
public function unit.damage(unit target, real amount, bool spell, int id)
	new Damage(this, target, amount, spell, id)..modify()..deal()

/** Deals triggered damage from unit to target. */
public function unit.damage(unit target, real amount, bool spell)
	new Damage(this, target, amount, spell, 0)..modify()..deal()
/** Deals triggered spell damage from unit to target. */
public function unit.damage(unit target, real amount)
	new Damage(this, target, amount, true, 0)..modify()..deal()

// ConvertAttackType(7) is a hidden attack type with some unique properties.
// For more information see "goo.gl/9k8tn".
// Note that the values in the table at this link are outdated, but the principle still applies.
constant ATTACK_TYPE_UNIVERSAL = ConvertAttackType(7)
constant DAMAGE_TYPE_CHECK_ID = compiletime(ABIL_ID_GEN.next())
constant CHEAT_DEATH_ID = compiletime(ABIL_ID_GEN.next())

public class Damage
	integer id
	unit source
	unit target
	bool spell
	real initial
	real amount

	/** Determines if target is needed to be saved. */
	protected bool doSaveTarget = false
	/** Call this if you want to save the target
		no matter the amount of damage. */ 
	function saveTarget()
		doSaveTarget = true

	/** Damage instances are automatically destroyed.
		Use this to protect them if you need that instances anyhow. */
	function saveInstance()
		wantSave += 1

	/** Releases Damage instance so it can be destroyed.
		It is destroyed immediately if anybody else haven't saved it. */
	function releaseInstance()
		wantSave -= 1
		if fired and wantSave <= 0
			destroy this

	/** The counter inside saveInstance() and releaseInstance(). */
	protected int wantSave = 0

	protected bool killingBlow = false
	private bool fired = false

	/** applied all modifiers to the damage instance once */
	function modify()
		for i in damageModifiers
			i.run(this)
	protected function anounce()
		for i in damageListeners
			i.run(this)

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return killingBlow or (not fired and target.getHP() - .405 < amount)
		
	/** Multiplies initial damage with given magnitude */
	function addMultiplier(real mult)
		amount += initial * (mult - 1)

	/** Increases damage amount with given amount */
	function addAmount(real amount)
		this.amount += amount
		
	construct(unit source, unit target, real amount, bool isSpell, int id)
		this.source = source
		this.target = target
		this.initial = amount
		this.amount = amount
		spell = isSpell
		this.id = id
		if id == DAMAGE_ID_NONTRIGGERED
			this.fired = true

	/** applies user-created Damage instance. */
	function deal()
		if not fired
			fired = true
			if target.isAlive()
				let life = target.getHP()
				killingBlow = life - .405 < amount
				if killingBlow and doSaveTarget
					amount = target.getHP() - .406
					killingBlow = false			
				dealCodeDamage(source, target, amount, killingBlow)
				anounce()
			if this.wantSave <= 0
				destroy this
		else
			Log.warn("Damage.deal() called on already fired damage!")

/** Deal an exact amount of damage to `target`, crediting kill experience and
	gold bounty to `attacker` and not triggering any of DamageDetection listeners. KillingBlow parameter decides whether to kill the target. Isn't supposed to use outside of the system. */
function dealCodeDamage(unit attacker, unit target, real damage, bool killingBlow)
	if damage != 0
		let hp = target.getHP()
		disableDamageDetect()
		if not killingBlow
			target.setHP(max(hp - damage, .405))
		else
			// Deal damage using two separate components. The ATTACK_TYPE_UNIVERSAL
			// case will deal damage to units of all armor types, even if that armor
			// would otherwise block all damage. The ATTACK_TYPE_MAGIC case affect
			// ethereal units, whereas other attack types do not.
			target.setHP(.405)
			attacker.damageTarget(target, 1000000., ATTACK_TYPE_UNIVERSAL)
			attacker.damageTarget(target, 1000000., ATTACK_TYPE_MAGIC)
		enableDamageDetect()

function handler() returns bool
	let damage = GetEventDamage()
	if damage == 0
		return false

	let d = new Damage(GetEventDamageSource(), GetTriggerUnit(), (damage < 0 ? -damage : damage), damage < 0, DAMAGE_ID_NONTRIGGERED)

	d.modify()

	let life = d.target.getHP()
	d.killingBlow = life - .405 < d.amount
	if d.killingBlow
		if d.doSaveTarget
			d.amount = life - .406
			d.killingBlow = false
		else
			// So the unit should die no matter what. The following line should secure it.
			d.amount = life // A bit of logic wc3 does not have - damage can't be greater than unit's life.
			dealCodeDamage(d.source, d.target, life, true) // DIE, INSECT!!!
			d.anounce()
			return false
		
	real rLife
	bool doTimer
	real afterDamage = 0
	if d.spell
		// After all: life += -d.amount - d.initial // + d.initial from event
		rLife = life - d.initial - d.amount
		doTimer = rLife < .405
		if doTimer
			afterDamage = d.initial + d.amount
	else
		// After all: life += -d.amount + d.initial // - d.initial from event 
		rLife = life + d.initial - d.amount
		doTimer = rLife > d.target.getMaxHP()
		if doTimer
			d.target.addAbility(CHEAT_DEATH_ID)
			d.target.setHP(rLife)
			
	if doTimer
		nullTimer() ->
			let hp = d.target.getHP()
			d.target.removeAbility(CHEAT_DEATH_ID)
			d.target.setHP(hp)
			dealCodeDamage(d.source, d.target, afterDamage, false)
			
			d.anounce()
		
			if d.wantSave == 0
				destroy d
	else
		d.target.setHP(rLife)
		d.anounce()

	return false

init
	onEnter() ->
		getEnterLeaveUnit()..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	addOnDamageFunc(Condition(function handler))

@compiletime function generateAbility()
	new AbilityDefinitionRunedBracers(DAMAGE_TYPE_CHECK_ID)
		..setName("Runed Bracer Dummy")
		..setEditorSuffix("(DamageType)")
		..setItemAbility(false)
		..setDamageReduction(1, 2.)
	new AbilityDefinitionAIhe(CHEAT_DEATH_ID)
		..setName("Cheat Death Dummy")
		..setEditorSuffix("(Damage)")
		..setItemAbility(false)
		..setHitPointsGained(1, 1000000)
