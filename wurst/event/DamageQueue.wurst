package DamageQueue
import DamageModify
import LinkedList
import TimerUtils

/*
	DamageQueue is created to make damage event listeners follow the same order
	in which damage are invoked and also protect from the infinite thorns problem.

	When damage is invoked, event listeners are run before target's health is
	changed, which can lead to some hard to track bugs if there is nested damage
	invokation, for example - DOTA's blademail.

	Explaining example:

	Test case:
	init
		addDamageListener() d ->
			Log.info("Start " + (d castTo int).toString())
		addDamageListener() d ->
			if d.data > 0
				d.getSource().damageTarget(d.getTarget(), d.getAmount() * d.data / (d.data+1), ATTACK_TYPE_NORMAL, d.data - 1).releaseInstance()
			// Make damage resonance
		addDamageListener() d ->
			Log.info("End " + (d castTo int).toString())

		// To demonstrate why is this even important
		addDamageModifier() d ->
			if d.getAmount() < d.getTarget().getMaxHP() / 2
				d.preventDeath()
				// Some tough guy's ability, who can't die from weak attacks

	Then somewhere happens this:
	unit2 has 101 hp out of 101.
	unit1.damageTarget(unit2, 75, 2)
	(Causing then 50 and 25 damage)
	
	Logs:
	Start 1
	Start 2
	Start 3
	End 3
	*unit 2 is hit with 25 damage, 76 left*
	End 2
	*unit 2 is hit with 50 damage, 26 left*
	End 1
	*unit 2 is hit with 75 (26 actual) damage, unit 2 dies.*

	If you replace .damageTarget with .damageTargetQueued, you'll get this
	result with in same test case:

	Start 1
	End 1
	*unit 2 is hit with 75 damage, 26 left*
	Start 2
	End 2
	*unit 2 is hit with 50 (25.594 actual) damage, 0.406 left*
	Start 3
	End 3
	*unit 2 is hit with 25 (0 actual) damage, unit 2 lives*

	So the results in this test are different if we take order into consideration.

	This is proved for war3 version 1.30.
	As you can see, in second case damage processing follows the order given
*/

@configurable constant RECURSION_TRESHOLD = 128

/** This is a replacement for .damageTarget() in case of nested damage call that
	delays new damage event to run after previous damage was dealt.
	
	More info on that in DamageQueue package. */
public function unit.damageTargetQueued(unit target, real amount, bool attack, bool ranged, attacktype attackType, damagetype damageType, weapontype weaponType, int data) returns Damage
	return new Damage(this, target, amount, attack, ranged, attackType, damageType, weaponType, data)..saveInstance()..modify()..dealQueued()

/** This is a replacement for .damageTarget() in case of nested damage call that
	delays new damage event to run after previous damage was dealt.
	
	More info on that in DamageQueue package. */
public function unit.damageTargetQueued(unit target, real amount, attacktype attackType, int data) returns Damage
	return this.damageTargetQueued(target, amount, false, false, attackType, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

/** This is a replacement for .damageTarget() in case of nested damage call that
	delays new damage event to run after previous damage was dealt.
	
	More info on that in DamageQueue package. */
public function unit.damageTargetQueued(unit target, real amount, int data) returns Damage
	return this.damageTargetQueued(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS, data)

let queue = new LinkedList<Damage>
/** This is a replacement for .deal() in case of nested damage call that
	delays new damage event to run after previous damage was dealt.
	
	More info on that in DamageQueue package. */
public function Damage.dealQueued()
	if queue.size() < 128
		if queue.isEmpty()
			getTimer()..start(0., function queueFlush)
		this.saveInstance()
		queue.add(this)
	else
		Log.debug("DamageQueue: recursion stopped.")

function queueFlush()
	while not queue.isEmpty()
		queue.dequeue()..deal()..releaseInstance()
	GetExpiredTimer().release()